{
    "Generator": {
        "Name": "PENGUINLIONG/tinyspv",
        "ScriptName": "gen-spec-json.py",
        "GitCommitHash": "e5ad4d5537421acc1b1e66d451db0d6f018a83ca"
    },
    "Enumerations": [
        {
            "Name": "Magic Number",
            "Cases": [
                {
                    "Value": "0x07230203"
                }
            ]
        },
        {
            "Name": "Source Language",
            "Cases": [
                {
                    "Name": "Unknown",
                    "Value": "0"
                },
                {
                    "Name": "ESSL",
                    "Value": "1"
                },
                {
                    "Name": "GLSL",
                    "Value": "2"
                },
                {
                    "Name": "OpenCL_C",
                    "Value": "3"
                },
                {
                    "Name": "OpenCL_CPP",
                    "Value": "4"
                },
                {
                    "Name": "HLSL",
                    "Value": "5"
                }
            ]
        },
        {
            "Name": "Execution Model",
            "Cases": [
                {
                    "Name": "Vertex",
                    "Description": "Vertex shading stage.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "TessellationControl",
                    "Description": "Tessellation control (or hull) shading stage.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "TessellationEvaluation",
                    "Description": "Tessellation evaluation (or domain) shading stage.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "Geometry",
                    "Description": "Geometry shading stage.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "Fragment",
                    "Description": "Fragment shading stage.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "4"
                },
                {
                    "Name": "GLCompute",
                    "Description": "Graphical compute shading stage.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "5"
                },
                {
                    "Name": "Kernel",
                    "Description": "Compute kernel.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "TaskNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "Value": "5267"
                },
                {
                    "Name": "MeshNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "Value": "5268"
                },
                {
                    "Name": "RayGenerationNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5313"
                },
                {
                    "Name": "RayGenerationKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5313"
                },
                {
                    "Name": "IntersectionNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5314"
                },
                {
                    "Name": "IntersectionKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5314"
                },
                {
                    "Name": "AnyHitNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5315"
                },
                {
                    "Name": "AnyHitKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5315"
                },
                {
                    "Name": "ClosestHitNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5316"
                },
                {
                    "Name": "ClosestHitKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5316"
                },
                {
                    "Name": "MissNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5317"
                },
                {
                    "Name": "MissKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5317"
                },
                {
                    "Name": "CallableNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5318"
                },
                {
                    "Name": "CallableKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "5318"
                }
            ]
        },
        {
            "Name": "Addressing Model",
            "Cases": [
                {
                    "Name": "Logical",
                    "Value": "0"
                },
                {
                    "Name": "Physical32",
                    "Description": "Indicates a 32-bit module, where the address width is equal to 32 bits.",
                    "EnablingCapabilities": [
                        "Addresses"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "Physical64",
                    "Description": "Indicates a 64-bit module, where the address width is equal to 64 bits.",
                    "EnablingCapabilities": [
                        "Addresses"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "PhysicalStorageBuffer64",
                    "Description": "Indicates that pointers with a storage class of PhysicalStorageBuffer are physical pointer types with an  address width of 64 bits, while pointers to all other storage classes are logical.",
                    "EnablingCapabilities": [
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer",
                        "SPV_KHR_physical_storage_buffer"
                    ],
                    "Value": "5348"
                },
                {
                    "Name": "PhysicalStorageBuffer64EXT",
                    "EnablingCapabilities": [
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer"
                    ],
                    "Value": "5348"
                }
            ]
        },
        {
            "Name": "Memory Model",
            "Cases": [
                {
                    "Name": "Simple",
                    "Description": "No shared memory consistency issues.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "GLSL450",
                    "Description": "Memory model needed by later versions of GLSL and ESSL.  Works across multiple versions.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "OpenCL",
                    "Description": "OpenCL memory model.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "Vulkan",
                    "Description": "Vulkan memory model, as specified by the client API. This memory model must be declared if and only if the VulkanMemoryModel capability is declared.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "3"
                },
                {
                    "Name": "VulkanKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "3"
                }
            ]
        },
        {
            "Name": "Execution Mode",
            "Cases": [
                {
                    "Name": "Invocations",
                    "Description": "Number of invocations is an unsigned 32-bit integer number of times to invoke the geometry stage for each input primitive received. The default is to run once for each input primitive. It is invalid to specify a value greater than the target-dependent maximum. Only valid with the Geometry Execution Model.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Number of invocations"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "SpacingEqual",
                    "Description": "Requests the tessellation primitive generator to divide edges into a collection of equal-sized segments. Only valid with one of the tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "SpacingFractionalEven",
                    "Description": "Requests the tessellation primitive generator to divide edges into an even number of equal-length segments plus two additional shorter fractional segments. Only valid with one of the tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "SpacingFractionalOdd",
                    "Description": "Requests the tessellation primitive generator to divide edges into an odd number of equal-length segments plus two additional shorter fractional segments. Only valid with one of the tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "VertexOrderCw",
                    "Description": "Requests the tessellation primitive generator to generate triangles in clockwise order. Only valid with one of the tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "4"
                },
                {
                    "Name": "VertexOrderCcw",
                    "Description": "Requests the tessellation primitive generator to generate triangles in counter-clockwise order. Only valid with one of the tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "5"
                },
                {
                    "Name": "PixelCenterInteger",
                    "Description": "Pixels appear centered on whole-number pixel offsets. E.g., the coordinate (0.5, 0.5) appears to move to (0.0, 0.0). Only valid with the Fragment Execution Model. If a Fragment entry point does not have this set, pixels appear centered at offsets of (0.5, 0.5) from whole numbers",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "OriginUpperLeft",
                    "Description": "The coordinates decorated by FragCoord appear to originate in the upper left, and increase toward the right and downward. Only valid with the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "7"
                },
                {
                    "Name": "OriginLowerLeft",
                    "Description": "The coordinates decorated by FragCoord appear to originate in the lower left, and increase toward the right and upward. Only valid with the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "8"
                },
                {
                    "Name": "EarlyFragmentTests",
                    "Description": "Fragment tests are to be performed before fragment shader execution. Only valid with the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "9"
                },
                {
                    "Name": "PointMode",
                    "Description": "Requests the tessellation primitive generator to generate a point for each distinct vertex in the subdivided primitive, rather than to generate lines or triangles. Only valid with one of the tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "10"
                },
                {
                    "Name": "Xfb",
                    "Description": "This stage runs in transform feedback-capturing mode and this module is responsible for describing the transform-feedback setup. See the XfbBuffer, Offset, and XfbStride Decorations.",
                    "EnablingCapabilities": [
                        "TransformFeedback"
                    ],
                    "Value": "11"
                },
                {
                    "Name": "DepthReplacing",
                    "Description": "This mode declares that this entry point dynamically writes the FragDepth-decorated variable. Behavior is undefined if this mode is declared and an invocation does not write to FragDepth, or vice versa. Only valid with the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "12"
                },
                {
                    "Name": "DepthGreater",
                    "Description": "Indicates that per-fragment tests may assume that any FragDepth built in-decorated value written by the shader is greater-than-or-equal to the fragment\u2019s interpolated depth value (given by the z component of the FragCoord built in-decorated variable). Other stages of the pipeline use the written value as normal. Only valid with the Fragment execution model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "14"
                },
                {
                    "Name": "DepthLess",
                    "Description": "Indicates that per-fragment tests may assume that any FragDepth built in-decorated value written by the shader is less-than-or-equal to the fragment\u2019s interpolated depth value (given by the z component of the FragCoord built in-decorated variable). Other stages of the pipeline use the written value as normal. Only valid with the Fragment execution model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "15"
                },
                {
                    "Name": "DepthUnchanged",
                    "Description": "Indicates that per-fragment tests may assume that any FragDepth built in-decorated value written by the shader is the same as the fragment\u2019s interpolated depth value (given by the z component of the FragCoord built in-decorated variable). Other stages of the pipeline use the written value as normal. Only valid with the Fragment execution model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "16"
                },
                {
                    "Name": "LocalSize",
                    "Description": "Indicates the work-group size in the x, y, and z dimensions. x size, y size, and z size are unsigned 32-bit integers. Only valid with the GLCompute or Kernel Execution Models.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "x size"
                        },
                        {
                            "Type": "Literal",
                            "Description": "y size"
                        },
                        {
                            "Type": "Literal",
                            "Description": "z size"
                        }
                    ],
                    "Value": "17"
                },
                {
                    "Name": "LocalSizeHint",
                    "Description": "A hint to the compiler, which indicates the most likely to be used work-group size in the x, y, and z dimensions. x size, y size, and z size are unsigned 32-bit integers. Only valid with the Kernel Execution Model.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "x size"
                        },
                        {
                            "Type": "Literal",
                            "Description": "y size"
                        },
                        {
                            "Type": "Literal",
                            "Description": "z size"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "18"
                },
                {
                    "Name": "InputPoints",
                    "Description": "Stage input primitive is points. Only valid with the Geometry Execution Model.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "19"
                },
                {
                    "Name": "InputLines",
                    "Description": "Stage input primitive is lines. Only valid with the Geometry Execution Model.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "20"
                },
                {
                    "Name": "InputLinesAdjacency",
                    "Description": "Stage input primitive is lines adjacency. Only valid with the Geometry Execution Model.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "21"
                },
                {
                    "Name": "Triangles",
                    "Description": "For a geometry stage, input primitive is triangles. For a tessellation stage, requests the tessellation primitive generator to generate triangles. Only valid with the Geometry or one of the tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Geometry",
                        "Tessellation"
                    ],
                    "Value": "22"
                },
                {
                    "Name": "InputTrianglesAdjacency",
                    "Description": "Geometry stage input primitive is triangles adjacency. Only valid with the Geometry Execution Model.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "23"
                },
                {
                    "Name": "Quads",
                    "Description": "Requests the tessellation primitive generator to generate quads. Only valid with one of the tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "24"
                },
                {
                    "Name": "Isolines",
                    "Description": "Requests the tessellation primitive generator to generate isolines. Only valid with one of the tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "25"
                },
                {
                    "Name": "OutputVertices",
                    "Description": "Vertex Count is an unsigned 32-bit integer. For a geometry stage, it is the maximum number of vertices the shader will ever emit in a single invocation. For a tessellation-control stage, it is the number of vertices in the output patch produced by the tessellation control shader, which also specifies the number of times the tessellation control shader is invoked. Only valid with the Geometry or one of the tessellation Execution Models.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Vertex count"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Geometry",
                        "Tessellation",
                        "MeshShadingNV"
                    ],
                    "Value": "26"
                },
                {
                    "Name": "OutputPoints",
                    "Description": "Stage output primitive is points. Only valid with the Geometry Execution Model.",
                    "EnablingCapabilities": [
                        "Geometry",
                        "MeshShadingNV"
                    ],
                    "Value": "27"
                },
                {
                    "Name": "OutputLineStrip",
                    "Description": "Stage output primitive is line strip. Only valid with the Geometry Execution Model.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "28"
                },
                {
                    "Name": "OutputTriangleStrip",
                    "Description": "Stage output primitive is triangle strip. Only valid with the Geometry Execution Model.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "29"
                },
                {
                    "Name": "VecTypeHint",
                    "Description": "A hint to the compiler, which indicates that most operations used in the entry point are explicitly vectorized using a particular vector type. The 16 high-order bits of the Vector Type operand specify the number of components of the vector. The 16 low-order bits of the Vector Type operand specify the data type of the vector.\nThese are the legal data type values:\n0 represents an 8-bit integer value.\n1 represents a 16-bit integer value.\n2 represents a 32-bit integer value.\n3 represents a 64-bit integer value.\n4 represents a 16-bit float value.\n5 represents a 32-bit float value.\n6 represents a 64-bit float value.\nOnly valid with the Kernel Execution Model.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Vector type"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "30"
                },
                {
                    "Name": "ContractionOff",
                    "Description": "Indicates that floating-point-expressions contraction is disallowed. Only valid with the Kernel Execution Model.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "31"
                },
                {
                    "Name": "Initializer",
                    "Description": "Indicates that this entry point is a module initializer.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MissingBefore": "1.1",
                    "Value": "33"
                },
                {
                    "Name": "Finalizer",
                    "Description": "Indicates that this entry point is a module finalizer.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MissingBefore": "1.1",
                    "Value": "34"
                },
                {
                    "Name": "SubgroupSize",
                    "Description": "Indicates that this entry point requires the specified Subgroup Size. Subgroup Size is an unsigned 32-bit integer.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Subgroup Size"
                        }
                    ],
                    "EnablingCapabilities": [
                        "SubgroupDispatch"
                    ],
                    "MissingBefore": "1.1",
                    "Value": "35"
                },
                {
                    "Name": "SubgroupsPerWorkgroup",
                    "Description": "Indicates that this entry point requires the specified number of Subgroups Per Workgroup. Subgroups Per Workgroup is an unsigned 32-bit integer.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Subgroups Per Workgroup"
                        }
                    ],
                    "EnablingCapabilities": [
                        "SubgroupDispatch"
                    ],
                    "MissingBefore": "1.1",
                    "Value": "36"
                },
                {
                    "Name": "SubgroupsPerWorkgroupId",
                    "Description": "Same as the  SubgroupsPerWorkgroup mode, but using an <id> operand instead of a literal. The operand is consumed as unsigned and  must be an integer type scalar.",
                    "ExtraOperands": [
                        {
                            "Type": "<id>",
                            "Description": "Subgroups Per Workgroup"
                        }
                    ],
                    "EnablingCapabilities": [
                        "SubgroupDispatch"
                    ],
                    "MissingBefore": "1.2",
                    "Value": "37"
                },
                {
                    "Name": "LocalSizeId",
                    "Description": "Same as the LocalSize Mode, but using <id> operands instead of literals. The operands are consumed as unsigned and each  must be an integer type scalar.",
                    "ExtraOperands": [
                        {
                            "Type": "<id>",
                            "Description": "x size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "y size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "z size"
                        }
                    ],
                    "MissingBefore": "1.2",
                    "Value": "38"
                },
                {
                    "Name": "LocalSizeHintId",
                    "Description": "Same as the LocalSizeHint Mode, but using <id> operands instead of literals. The operands are consumed as unsigned and each  must be an integer type scalar.",
                    "ExtraOperands": [
                        {
                            "Type": "<id>",
                            "Description": "Local Size Hint"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MissingBefore": "1.2",
                    "Value": "39"
                },
                {
                    "Name": "PostDepthCoverage",
                    "EnablingCapabilities": [
                        "SampleMaskPostDepthCoverage"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_post_depth_coverage"
                    ],
                    "Value": "4446"
                },
                {
                    "Name": "DenormPreserve",
                    "Description": "Any denormalized value input into a shader or potentially generated by any instruction in a shader is preserved. Denormalized values obtained via unpacking an integer into a vector of values with smaller bit width and interpreting those values as floating-point numbers is preserved.\nOnly affects instructions operating on a floating-point type whose component width is Target Width. Target Width is an unsigned 32-bit integer.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Target Width"
                        }
                    ],
                    "EnablingCapabilities": [
                        "DenormPreserve"
                    ],
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4459"
                },
                {
                    "Name": "DenormFlushToZero",
                    "Description": "Any denormalized value input into a shader or potentially generated by any instruction in a shader is flushed to zero. Denormalized values obtained via unpacking an integer into a vector of values with smaller bit width and interpreting those values as floating-point numbers is flushed to zero.\nOnly affects instructions operating on a floating-point type whose component width is Target Width. Target Width is an unsigned 32-bit integer.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Target Width"
                        }
                    ],
                    "EnablingCapabilities": [
                        "DenormFlushToZero"
                    ],
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4460"
                },
                {
                    "Name": "SignedZeroInfNanPreserve",
                    "Description": "The implementation does not perform optimizations on floating-point instructions that do not preserve sign of a zero, or assume that operands and results are not NaNs or infinities. Bit patterns for NaNs might not be preserved.\nOnly affects instructions operating on a floating-point type whose component width is Target Width. Target Width is an unsigned 32-bit integer.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Target Width"
                        }
                    ],
                    "EnablingCapabilities": [
                        "SignedZeroInfNanPreserve"
                    ],
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4461"
                },
                {
                    "Name": "RoundingModeRTE",
                    "Description": "The default rounding mode for floating-point arithmetic and conversions instructions is round to nearest even. If an instruction is decorated with FPRoundingMode or defines a rounding mode in its description, that rounding mode is applied and RoundingModeRTE is ignored.\nOnly affects instructions operating on a floating-point type whose component width is Target Width. Target Width is an unsigned 32-bit integer.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Target Width"
                        }
                    ],
                    "EnablingCapabilities": [
                        "RoundingModeRTE"
                    ],
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4462"
                },
                {
                    "Name": "RoundingModeRTZ",
                    "Description": "The default rounding mode for floating-point arithmetic and conversions instructions is round toward zero. If an instruction is decorated with FPRoundingMode or defines a rounding mode in its description, that rounding mode is applied and RoundingModeRTZ is ignored.\nOnly affects instructions operating on a floating-point type whose component width is Target Width. Target Width is an unsigned 32-bit integer.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Target Width"
                        }
                    ],
                    "EnablingCapabilities": [
                        "RoundingModeRTZ"
                    ],
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4463"
                },
                {
                    "Name": "StencilRefReplacingEXT",
                    "EnablingCapabilities": [
                        "StencilExportEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_shader_stencil_export"
                    ],
                    "Value": "5027"
                },
                {
                    "Name": "OutputLinesNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5269"
                },
                {
                    "Name": "OutputPrimitivesNV",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Primitive count"
                        }
                    ],
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5270"
                },
                {
                    "Name": "DerivativeGroupQuadsNV",
                    "EnablingCapabilities": [
                        "ComputeDerivativeGroupQuadsNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_compute_shader_derivatives"
                    ],
                    "Value": "5289"
                },
                {
                    "Name": "DerivativeGroupLinearNV",
                    "EnablingCapabilities": [
                        "ComputeDerivativeGroupLinearNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_compute_shader_derivatives"
                    ],
                    "Value": "5290"
                },
                {
                    "Name": "OutputTrianglesNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5298"
                },
                {
                    "Name": "PixelInterlockOrderedEXT",
                    "EnablingCapabilities": [
                        "FragmentShaderPixelInterlockEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_shader_interlock"
                    ],
                    "Value": "5366"
                },
                {
                    "Name": "PixelInterlockUnorderedEXT",
                    "EnablingCapabilities": [
                        "FragmentShaderPixelInterlockEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_shader_interlock"
                    ],
                    "Value": "5367"
                },
                {
                    "Name": "SampleInterlockOrderedEXT",
                    "EnablingCapabilities": [
                        "FragmentShaderSampleInterlockEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_shader_interlock"
                    ],
                    "Value": "5368"
                },
                {
                    "Name": "SampleInterlockUnorderedEXT",
                    "EnablingCapabilities": [
                        "FragmentShaderSampleInterlockEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_shader_interlock"
                    ],
                    "Value": "5369"
                },
                {
                    "Name": "ShadingRateInterlockOrderedEXT",
                    "EnablingCapabilities": [
                        "FragmentShaderShadingRateInterlockEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_shader_interlock"
                    ],
                    "Value": "5370"
                },
                {
                    "Name": "ShadingRateInterlockUnorderedEXT",
                    "EnablingCapabilities": [
                        "FragmentShaderShadingRateInterlockEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_shader_interlock"
                    ],
                    "Value": "5371"
                },
                {
                    "Name": "MaxWorkgroupSizeINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "max_x_size"
                        },
                        {
                            "Type": "Literal",
                            "Description": "max_y_size"
                        },
                        {
                            "Type": "Literal",
                            "Description": "max_z_size"
                        }
                    ],
                    "EnablingCapabilities": [
                        "KernelAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_kernel_attributes"
                    ],
                    "Value": "5893"
                },
                {
                    "Name": "MaxWorkDimINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "max_dimensions"
                        }
                    ],
                    "EnablingCapabilities": [
                        "KernelAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_kernel_attributes"
                    ],
                    "Value": "5894"
                },
                {
                    "Name": "NoGlobalOffsetINTEL",
                    "EnablingCapabilities": [
                        "KernelAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_kernel_attributes"
                    ],
                    "Value": "5895"
                },
                {
                    "Name": "NumSIMDWorkitemsINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "vector_width"
                        }
                    ],
                    "EnablingCapabilities": [
                        "FPGAKernelAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_kernel_attributes"
                    ],
                    "Value": "5896"
                }
            ]
        },
        {
            "Name": "Storage Class",
            "Cases": [
                {
                    "Name": "UniformConstant",
                    "Description": "Shared externally, visible across all functions in all invocations in all work groups. Graphics uniform memory. OpenCL constant memory. Variables declared with this storage class are read-only. They may have initializers, as allowed by the client API.",
                    "Value": "0"
                },
                {
                    "Name": "Input",
                    "Description": "Input from pipeline. Visible across all functions in the current invocation. Variables declared with this storage class are read-only, and must not have initializers.",
                    "Value": "1"
                },
                {
                    "Name": "Uniform",
                    "Description": "Shared externally, visible across all functions in all invocations in all work groups. Graphics uniform blocks and buffer blocks.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "Output",
                    "Description": "Output to pipeline. Visible across all functions in the current invocation.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "Workgroup",
                    "Description": "Shared across all invocations within a work group. Visible across all functions. The OpenGL \"shared\" storage qualifier.  OpenCL local memory.",
                    "Value": "4"
                },
                {
                    "Name": "CrossWorkgroup",
                    "Description": "Visible across all functions of all invocations of all work groups. OpenCL global memory.",
                    "Value": "5"
                },
                {
                    "Name": "Private",
                    "Description": "Visible to all functions in the current invocation. Regular global memory.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "Function",
                    "Description": "Visible only within the declaring function of the current invocation. Regular function memory.",
                    "Value": "7"
                },
                {
                    "Name": "Generic",
                    "Description": "For generic pointers, which overload the Function, Workgroup, and CrossWorkgroup Storage Classes.",
                    "EnablingCapabilities": [
                        "GenericPointer"
                    ],
                    "Value": "8"
                },
                {
                    "Name": "PushConstant",
                    "Description": "For holding push-constant memory, visible across all functions in all invocations in all work groups. Intended to contain a small bank of values pushed from the client API. Variables declared with this storage class are read-only, and must not have initializers.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "9"
                },
                {
                    "Name": "AtomicCounter",
                    "Description": "For holding atomic counters.  Visible across all functions of the current invocation. Atomic counter-specific memory.",
                    "EnablingCapabilities": [
                        "AtomicStorage"
                    ],
                    "Value": "10"
                },
                {
                    "Name": "Image",
                    "Description": "For holding image memory.",
                    "Value": "11"
                },
                {
                    "Name": "StorageBuffer",
                    "Description": "Shared externally, readable and writable, visible across all functions in all invocations in all work groups. Graphics storage buffers (buffer blocks).",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_storage_buffer_storage_class",
                        "SPV_KHR_variable_pointers"
                    ],
                    "Value": "12"
                },
                {
                    "Name": "CallableDataNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5328"
                },
                {
                    "Name": "CallableDataKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5328"
                },
                {
                    "Name": "IncomingCallableDataNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5329"
                },
                {
                    "Name": "IncomingCallableDataKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5329"
                },
                {
                    "Name": "RayPayloadNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5338"
                },
                {
                    "Name": "RayPayloadKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5338"
                },
                {
                    "Name": "HitAttributeNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5339"
                },
                {
                    "Name": "HitAttributeKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5339"
                },
                {
                    "Name": "IncomingRayPayloadNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5342"
                },
                {
                    "Name": "IncomingRayPayloadKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5342"
                },
                {
                    "Name": "ShaderRecordBufferNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5343"
                },
                {
                    "Name": "ShaderRecordBufferKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5343"
                },
                {
                    "Name": "PhysicalStorageBuffer",
                    "Description": "Shared externally, readable and writable, visible across all functions in all invocations in all work groups. Graphics storage buffers using physical addressing.",
                    "EnablingCapabilities": [
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer",
                        "SPV_KHR_physical_storage_buffer"
                    ],
                    "Value": "5349"
                },
                {
                    "Name": "PhysicalStorageBufferEXT",
                    "EnablingCapabilities": [
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer"
                    ],
                    "Value": "5349"
                },
                {
                    "Name": "CodeSectionINTEL",
                    "EnablingCapabilities": [
                        "FunctionPointersINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_function_pointers"
                    ],
                    "Value": "5605"
                }
            ]
        },
        {
            "Name": "Dim",
            "Cases": [
                {
                    "Name": "1D",
                    "EnablingCapabilities": [
                        "Sampled1D",
                        "Image1D"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "2D",
                    "EnablingCapabilities": [
                        "Shader",
                        "Kernel",
                        "ImageMSArray"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "3D",
                    "Value": "2"
                },
                {
                    "Name": "Cube",
                    "EnablingCapabilities": [
                        "Shader",
                        "ImageCubeArray"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "Rect",
                    "EnablingCapabilities": [
                        "SampledRect",
                        "ImageRect"
                    ],
                    "Value": "4"
                },
                {
                    "Name": "Buffer",
                    "EnablingCapabilities": [
                        "SampledBuffer",
                        "ImageBuffer"
                    ],
                    "Value": "5"
                },
                {
                    "Name": "SubpassData",
                    "EnablingCapabilities": [
                        "InputAttachment"
                    ],
                    "Value": "6"
                }
            ]
        },
        {
            "Name": "Sampler Addressing Mode",
            "Cases": [
                {
                    "Name": "None",
                    "Description": "The image coordinates used to sample elements of the image refer to a location inside the image, otherwise the results are undefined.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "ClampToEdge",
                    "Description": "Out-of-range image coordinates are clamped to the extent.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "Clamp",
                    "Description": "Out-of-range image coordinates result in a border color.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "Repeat",
                    "Description": "Out-of-range image coordinates are wrapped to the valid range. Must only be used with normalized coordinates.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "RepeatMirrored",
                    "Description": "Flip the image coordinate at every integer junction. Must only be used with normalized coordinates.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "4"
                }
            ]
        },
        {
            "Name": "Sampler Filter Mode",
            "Cases": [
                {
                    "Name": "Nearest",
                    "Description": "Use filter nearest mode when performing a read image operation.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "Linear",
                    "Description": "Use filter linear mode when performing a read image operation.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "1"
                }
            ]
        },
        {
            "Name": "Image Format",
            "Cases": [
                {
                    "Name": "Unknown",
                    "Value": "0"
                },
                {
                    "Name": "Rgba32f",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "Rgba16f",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "R32f",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "Rgba8",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "4"
                },
                {
                    "Name": "Rgba8Snorm",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "5"
                },
                {
                    "Name": "Rg32f",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "Rg16f",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "7"
                },
                {
                    "Name": "R11fG11fB10f",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "8"
                },
                {
                    "Name": "R16f",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "9"
                },
                {
                    "Name": "Rgba16",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "10"
                },
                {
                    "Name": "Rgb10A2",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "11"
                },
                {
                    "Name": "Rg16",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "12"
                },
                {
                    "Name": "Rg8",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "13"
                },
                {
                    "Name": "R16",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "14"
                },
                {
                    "Name": "R8",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "15"
                },
                {
                    "Name": "Rgba16Snorm",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "16"
                },
                {
                    "Name": "Rg16Snorm",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "17"
                },
                {
                    "Name": "Rg8Snorm",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "18"
                },
                {
                    "Name": "R16Snorm",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "19"
                },
                {
                    "Name": "R8Snorm",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "20"
                },
                {
                    "Name": "Rgba32i",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "21"
                },
                {
                    "Name": "Rgba16i",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "22"
                },
                {
                    "Name": "Rgba8i",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "23"
                },
                {
                    "Name": "R32i",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "24"
                },
                {
                    "Name": "Rg32i",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "25"
                },
                {
                    "Name": "Rg16i",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "26"
                },
                {
                    "Name": "Rg8i",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "27"
                },
                {
                    "Name": "R16i",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "28"
                },
                {
                    "Name": "R8i",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "29"
                },
                {
                    "Name": "Rgba32ui",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "30"
                },
                {
                    "Name": "Rgba16ui",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "31"
                },
                {
                    "Name": "Rgba8ui",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "32"
                },
                {
                    "Name": "R32ui",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "33"
                },
                {
                    "Name": "Rgb10a2ui",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "34"
                },
                {
                    "Name": "Rg32ui",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "35"
                },
                {
                    "Name": "Rg16ui",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "36"
                },
                {
                    "Name": "Rg8ui",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "37"
                },
                {
                    "Name": "R16ui",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "38"
                },
                {
                    "Name": "R8ui",
                    "EnablingCapabilities": [
                        "StorageImageExtendedFormats"
                    ],
                    "Value": "39"
                },
                {
                    "Name": "R64ui",
                    "EnablingCapabilities": [
                        "Int64ImageEXT"
                    ],
                    "Value": "40"
                },
                {
                    "Name": "R64i",
                    "EnablingCapabilities": [
                        "Int64ImageEXT"
                    ],
                    "Value": "41"
                }
            ]
        },
        {
            "Name": "Image Channel Order",
            "Cases": [
                {
                    "Name": "R",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "A",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "RG",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "RA",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "RGB",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "4"
                },
                {
                    "Name": "RGBA",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "5"
                },
                {
                    "Name": "BGRA",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "ARGB",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "7"
                },
                {
                    "Name": "Intensity",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "8"
                },
                {
                    "Name": "Luminance",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "9"
                },
                {
                    "Name": "Rx",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "10"
                },
                {
                    "Name": "RGx",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "11"
                },
                {
                    "Name": "RGBx",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "12"
                },
                {
                    "Name": "Depth",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "13"
                },
                {
                    "Name": "DepthStencil",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "14"
                },
                {
                    "Name": "sRGB",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "15"
                },
                {
                    "Name": "sRGBx",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "16"
                },
                {
                    "Name": "sRGBA",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "17"
                },
                {
                    "Name": "sBGRA",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "18"
                },
                {
                    "Name": "ABGR",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "19"
                }
            ]
        },
        {
            "Name": "Image Channel Data Type",
            "Cases": [
                {
                    "Name": "SnormInt8",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "SnormInt16",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "UnormInt8",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "UnormInt16",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "UnormShort565",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "4"
                },
                {
                    "Name": "UnormShort555",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "5"
                },
                {
                    "Name": "UnormInt101010",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "SignedInt8",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "7"
                },
                {
                    "Name": "SignedInt16",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "8"
                },
                {
                    "Name": "SignedInt32",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "9"
                },
                {
                    "Name": "UnsignedInt8",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "10"
                },
                {
                    "Name": "UnsignedInt16",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "11"
                },
                {
                    "Name": "UnsignedInt32",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "12"
                },
                {
                    "Name": "HalfFloat",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "13"
                },
                {
                    "Name": "Float",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "14"
                },
                {
                    "Name": "UnormInt24",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "15"
                },
                {
                    "Name": "UnormInt101010_2",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "16"
                }
            ]
        },
        {
            "Name": "Image Operands",
            "Cases": [
                {
                    "Name": "None",
                    "Value": "0x0"
                },
                {
                    "Name": "Bias",
                    "Description": "A following operand is the bias added to the implicit level of detail. Only valid with implicit-lod instructions. It must be a floating-point type scalar.  This must only be used with an OpTypeImage that has a Dim operand of 1D, 2D, 3D, or Cube, and the MS operand must be 0.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "0x1"
                },
                {
                    "Name": "Lod",
                    "Description": "A following operand is the explicit level-of-detail to use.  Only valid with explicit-lod instructions. For sampling operations, it must be a floating-point type scalar.  For fetch operations, it must be an integer type scalar.  This must only be used with an OpTypeImage that has a Dim operand of 1D, 2D, 3D, or Cube, and the MS operand must be 0.",
                    "Value": "0x2"
                },
                {
                    "Name": "Grad",
                    "Description": "Two following operands are dx followed by dy. These are explicit derivatives in the x and y direction to use in computing level of detail. Each is a scalar or vector containing (du/dx[, dv/dx] [, dw/dx]) and (du/dy[, dv/dy] [, dw/dy]). The number of components of each must equal the number of components in Coordinate, minus the array layer component, if present. Only valid with explicit-lod instructions. They must be a scalar or vector of floating-point type.  This must only be used with an OpTypeImage that has an MS operand of 0. It is invalid to set both the Lod and Grad bits.",
                    "Value": "0x4"
                },
                {
                    "Name": "ConstOffset",
                    "Description": "A following operand is added to (u, v, w) before texel lookup. It must be an <id> of an integer-based constant instruction of scalar or vector type. It is invalid for these to be outside a target-dependent allowed range. The number of components must equal the number of components in Coordinate, minus the array layer component, if present. Not valid with the Cube dimension. An instruction must specify at most one of the ConstOffset, Offset, and ConstOffsets image operands.",
                    "Value": "0x8"
                },
                {
                    "Name": "Offset",
                    "Description": "A following operand is added to (u, v, w) before texel lookup. It  must be a scalar or vector of integer type.  It is invalid for these to be outside a target-dependent allowed range. The number of components must equal the number of components in Coordinate, minus the array layer component, if present. Not valid with the Cube dimension. An instruction must specify at most one of the ConstOffset, Offset, and ConstOffsets image operands.",
                    "EnablingCapabilities": [
                        "ImageGatherExtended"
                    ],
                    "Value": "0x10"
                },
                {
                    "Name": "ConstOffsets",
                    "Description": "A following operand is Offsets. Offsets must be an <id> of a constant instruction making an array of size four of vectors of two integer components. Each gathered texel is identified by adding one of these array elements to the (u, v) sampled location. It is invalid for these to be outside a target-dependent allowed range. Only valid with OpImageGather or OpImageDrefGather. Not valid with the Cube dimension. An instruction must specify at most one of the ConstOffset, Offset, and ConstOffsets image operands.",
                    "EnablingCapabilities": [
                        "ImageGatherExtended"
                    ],
                    "Value": "0x20"
                },
                {
                    "Name": "Sample",
                    "Description": "A following operand is the sample number of the sample to use. Only valid with OpImageFetch, OpImageRead, OpImageWrite, OpImageSparseFetch, and OpImageSparseRead. The Sample operand must be used if and only if the underlying OpTypeImage has MS of 1. It must be an integer type scalar.",
                    "Value": "0x40"
                },
                {
                    "Name": "MinLod",
                    "Description": "A following operand is the minimum level-of-detail to use when accessing the image. Only valid with Implicit instructions and Grad instructions. It must be a floating-point type scalar.  This must only be used with an OpTypeImage that has a Dim operand of 1D, 2D, 3D, or Cube, and the MS operand must be 0.",
                    "EnablingCapabilities": [
                        "MinLod"
                    ],
                    "Value": "0x80"
                },
                {
                    "Name": "MakeTexelAvailable",
                    "Description": "Perform an availability operation on the texel locations after the store. A following operand is the memory scope that controls the availability operation. Requires NonPrivateTexel to also be set. Only valid with OpImageWrite.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x100"
                },
                {
                    "Name": "MakeTexelAvailableKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x100"
                },
                {
                    "Name": "MakeTexelVisible",
                    "Description": "Perform a visibility operation on the texel locations before the load. A following operand is the memory scope that controls the visibility operation. Requires NonPrivateTexel to also be set. Only valid with OpImageRead and OpImageSparseRead.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x200"
                },
                {
                    "Name": "MakeTexelVisibleKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x200"
                },
                {
                    "Name": "NonPrivateTexel",
                    "Description": "The image access obeys inter-thread ordering, as specified by the client API.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x400"
                },
                {
                    "Name": "NonPrivateTexelKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x400"
                },
                {
                    "Name": "VolatileTexel",
                    "Description": "This access cannot be eliminated, duplicated, or combined with other accesses.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x800"
                },
                {
                    "Name": "VolatileTexelKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x800"
                },
                {
                    "Name": "SignExtend",
                    "Description": "The texel value is converted to the target value via sign extension. Only valid if the texel type is a scalar or vector of integer type.",
                    "MissingBefore": "1.4",
                    "Value": "0x1000"
                },
                {
                    "Name": "ZeroExtend",
                    "Description": "The texel value is converted to the target value via zero extension. Only valid if the texel type is a scalar or vector of integer type.",
                    "MissingBefore": "1.4",
                    "Value": "0x2000"
                }
            ]
        },
        {
            "Name": "FP Fast Math Mode",
            "Cases": [
                {
                    "Name": "None",
                    "Value": "0x0"
                },
                {
                    "Name": "NotNaN",
                    "Description": "Assume parameters and result are not NaN.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0x1"
                },
                {
                    "Name": "NotInf",
                    "Description": "Assume parameters and result are not +/- Inf.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0x2"
                },
                {
                    "Name": "NSZ",
                    "Description": "Treat the sign of a zero parameter or result as insignificant.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0x4"
                },
                {
                    "Name": "AllowRecip",
                    "Description": "Allow the usage of reciprocal rather than perform a division.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0x8"
                },
                {
                    "Name": "Fast",
                    "Description": "Allow algebraic transformations according to real-number associative and distributive algebra. This flag implies all the others.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0x10"
                }
            ]
        },
        {
            "Name": "FP Rounding Mode",
            "Cases": [
                {
                    "Name": "RTE",
                    "Description": "Round to nearest even.",
                    "Value": "0"
                },
                {
                    "Name": "RTZ",
                    "Description": "Round towards zero.",
                    "Value": "1"
                },
                {
                    "Name": "RTP",
                    "Description": "Round towards positive infinity.",
                    "Value": "2"
                },
                {
                    "Name": "RTN",
                    "Description": "Round towards negative infinity.",
                    "Value": "3"
                }
            ]
        },
        {
            "Name": "Linkage Type",
            "Cases": [
                {
                    "Name": "Export",
                    "Description": "Accessible by other modules as well.",
                    "EnablingCapabilities": [
                        "Linkage"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "Import",
                    "Description": "A declaration of a global variable or a function that exists in another module.",
                    "EnablingCapabilities": [
                        "Linkage"
                    ],
                    "Value": "1"
                }
            ]
        },
        {
            "Name": "Access Qualifier",
            "Cases": [
                {
                    "Name": "ReadOnly",
                    "Description": "A read-only object.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "WriteOnly",
                    "Description": "A write-only object.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "ReadWrite",
                    "Description": "A readable and writable object.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "2"
                }
            ]
        },
        {
            "Name": "Function Parameter Attribute",
            "Cases": [
                {
                    "Name": "Zext",
                    "Description": "Zero extend the value, if needed.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "Sext",
                    "Description": "Sign extend the value, if needed.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "ByVal",
                    "Description": "Pass the parameter by value to the function. Only valid for pointer parameters (not for ret value).",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "Sret",
                    "Description": "The parameter is the address of a structure that is the return value of the function in the source program. Only applicable to the first parameter, which must be a pointer parameter.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "NoAlias",
                    "Description": "The memory pointed to by a pointer parameter is not accessed via pointer values that are not derived from this pointer parameter. Only valid for pointer parameters. Not valid on return values.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "4"
                },
                {
                    "Name": "NoCapture",
                    "Description": "The parameter is not copied into a location that is accessible after returning from the callee. Only valid for pointer parameters. Not valid on return values.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "5"
                },
                {
                    "Name": "NoWrite",
                    "Description": "Only reads the memory pointed to by a pointer parameter. Only valid for pointer parameters. Not valid on return values.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "NoReadWrite",
                    "Description": "The memory pointed to by a parameter is not dereferenced. Only valid for pointer parameters. Not valid on return values.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "7"
                }
            ]
        },
        {
            "Name": "Decoration",
            "Cases": [
                {
                    "Name": "RelaxedPrecision",
                    "Description": "Allow reduced precision operations. To be used as described in Relaxed Precision.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "SpecId",
                    "Description": "Apply only to a scalar specialization constant. Specialization Constant ID is an unsigned 32-bit integer forming the external linkage for setting a specialized value. See specialization.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Specialization Constant ID"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Shader",
                        "Kernel"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "Block",
                    "Description": "Apply only to a structure type to establish it is a non-SSBO-like shader-interface block.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "BufferBlock",
                    "Description": "Deprecated (use Block-decorated StorageBuffer Storage Class objects).\nApply only to a structure type to establish it is an SSBO-like shader-interface block.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingAfter": "1.3",
                    "Value": "3"
                },
                {
                    "Name": "RowMajor",
                    "Description": "Applies only to a member of a structure type.  Only valid on a matrix or array whose most basic element is a matrix. Indicates that components within a row are contiguous in memory. Must not be used with ColMajor on the same matrix or matrix aggregate.",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "Value": "4"
                },
                {
                    "Name": "ColMajor",
                    "Description": "Applies only to a member of a structure type.  Only valid on a matrix or array whose most basic element is a matrix. Indicates that components within a column are contiguous in memory. Must not be used with RowMajor on the same matrix or matrix aggregate.",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "Value": "5"
                },
                {
                    "Name": "ArrayStride",
                    "Description": "Apply to an array type to specify the stride, in bytes, of the array\u2019s elements. Can also apply to a pointer type to an array element.  Array Stride is an unsigned 32-bit integer specifying the stride of the array that the element resides in. Must not be applied to any other type.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Array Stride"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "MatrixStride",
                    "Description": "Applies only to a member of a structure type.  Only valid on a matrix or array whose most basic element is a matrix. Matrix Stride is an unsigned 32-bit integer specifying the stride of the rows in a RowMajor-decorated matrix or columns in a ColMajor-decorated matrix.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Matrix Stride"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "Value": "7"
                },
                {
                    "Name": "GLSLShared",
                    "Description": "Apply only to a structure type to get GLSL shared memory layout.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "8"
                },
                {
                    "Name": "GLSLPacked",
                    "Description": "Apply only to a structure type to get GLSL packed memory layout.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "9"
                },
                {
                    "Name": "CPacked",
                    "Description": "Apply only to a structure type, to marks it as \"packed\", indicating that the alignment of the structure is one and that there is no padding between structure members.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "10"
                },
                {
                    "Name": "BuiltIn",
                    "Description": "Indicates which built-in variable an object represents.  See BuiltIn for more information.",
                    "ExtraOperands": [
                        {
                            "Type": "BuiltIn"
                        }
                    ],
                    "Value": "11"
                },
                {
                    "Name": "NoPerspective",
                    "Description": "Must only be used on a memory object declaration or a member of a structure type.  Requests linear, non-perspective correct, interpolation. Only valid for the Input and Output Storage Classes.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "13"
                },
                {
                    "Name": "Flat",
                    "Description": "Must only be used on a memory object declaration or a member of a structure type.  Indicates no interpolation is done. The non-interpolated value comes from a vertex, as specified by the client API. Only valid for the Input and Output Storage Classes.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "14"
                },
                {
                    "Name": "Patch",
                    "Description": "Must only be used on a memory object declaration or a member of a structure type.  Indicates a tessellation patch. Only valid for the Input and Output Storage Classes.  Invalid to use on objects or types referenced by non-tessellation Execution Models.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "15"
                },
                {
                    "Name": "Centroid",
                    "Description": "Must only be used on a memory object declaration or a member of a structure type. If used with multi-sampling rasterization, allows a single interpolation location for an entire pixel. The interpolation location lies in both the pixel and in the primitive being rasterized. Only valid for the Input and Output Storage Classes.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "16"
                },
                {
                    "Name": "Sample",
                    "Description": "Must only be used on a memory object declaration or a member of a structure type. If used with multi-sampling rasterization, requires per-sample interpolation. The interpolation locations are the locations of the samples lying in both the pixel and in the primitive being rasterized. Only valid for the Input and Output Storage Classes.",
                    "EnablingCapabilities": [
                        "SampleRateShading"
                    ],
                    "Value": "17"
                },
                {
                    "Name": "Invariant",
                    "Description": "Apply only to a variable or member of a block-decorated structure type to indicate that expressions computing its value be computed invariantly with respect to other shaders computing the same expressions.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "18"
                },
                {
                    "Name": "Restrict",
                    "Description": "Apply only to a memory object declaration, to indicate the compiler may compile as if there is no aliasing.  See the Aliasing section for more detail.",
                    "Value": "19"
                },
                {
                    "Name": "Aliased",
                    "Description": "Apply only to a memory object declaration, to indicate the compiler is to generate accesses to the variable that work correctly in the presence of aliasing.  See the Aliasing section for more detail.",
                    "Value": "20"
                },
                {
                    "Name": "Volatile",
                    "Description": "Must be applied only to memory object declarations or members of a structure type. Any such memory object declaration, or any memory object declaration that contains such a structure type, must be one of:\n- A storage image (see OpTypeImage).\n- A block in the StorageBuffer storage class, or in the   Uniform storage class with the BufferBlock decoration.\nThis indicates the memory holding the variable is volatile memory. Accesses to volatile memory cannot be eliminated, duplicated, or combined with other accesses. Volatile applies only to a single invocation and does not guarantee each invocation performs the access.\nVolatile is not allowed if the declared memory model is Vulkan. The memory operand bit Volatile, the image operand bit VolatileTexel, or  the memory semantic bit Volatile can be used instead.",
                    "Value": "21"
                },
                {
                    "Name": "Constant",
                    "Description": "Indicates that a global variable is constant and never modified. Only allowed on global variables.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "22"
                },
                {
                    "Name": "Coherent",
                    "Description": "Must be applied only to memory object declarations or members of a structure type. Any such memory object declaration, or any memory object declaration that contains such a structure type, must be one of:\n- A storage image (see OpTypeImage).\n- A block in the StorageBuffer storage class, or in the   Uniform storage class with the BufferBlock decoration.\nThis indicates the memory backing the object is coherent.\nCoherent is not allowed if the declared memory model is Vulkan. The memory operand bits MakePointerAvailable and MakePointerVisible or the image operand bits MakeTexelAvailable and MakeTexelVisible can be used instead.",
                    "Value": "23"
                },
                {
                    "Name": "NonWritable",
                    "Description": "Must be applied only to memory object declarations or members of a structure type. Any such memory object declaration, or any memory object declaration that contains such a structure type, must be one of:\n- A storage image (see OpTypeImage).\n- A block in the StorageBuffer storage class, or in the   Uniform storage class with the BufferBlock decoration.\n- Missing before version 1.4: An object in the Private or Function storage classes.\nThis decoration indicates the memory holding the variable is not writable, and that this module does not write to it. It does not prevent the use of initializers on a declaration.",
                    "Value": "24"
                },
                {
                    "Name": "NonReadable",
                    "Description": "Must be applied only to memory object declarations or members of a structure type. Any such memory object declaration, or any memory object declaration that contains such a structure type, must be one of:\n- A storage image (see OpTypeImage).\n- A block in the StorageBuffer storage class, or in the   Uniform storage class with the BufferBlock decoration.\nThis indicates the memory holding the variable is not readable, and that this module does not read from it.",
                    "Value": "25"
                },
                {
                    "Name": "Uniform",
                    "Description": "Apply only to an object. Asserts that, for each dynamic instance of the instruction that computes the result, all active invocations in the invocation\u2019s Subgroup scope compute the same result value.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "26"
                },
                {
                    "Name": "UniformId",
                    "Description": "Apply only to an object. Asserts that, for each dynamic instance of the instruction that computes the result, all active invocations in the Execution scope compute the same result value. Execution must not be Invocation.",
                    "ExtraOperands": [
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.4",
                    "Value": "27"
                },
                {
                    "Name": "SaturatedConversion",
                    "Description": "Indicates that a conversion to an integer type which is outside the representable range of Result Type is clamped to the nearest representable value of Result Type. NaN is converted to 0.\nThis decoration must be applied only to conversion instructions to integer types, not including the OpSatConvertUToS and OpSatConvertSToU instructions.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "28"
                },
                {
                    "Name": "Stream",
                    "Description": "Must only be used on a memory object declaration or a member of a structure type.  Stream Number is an unsigned 32-bit integer indicating the stream number to put an output on. Only valid for the Output Storage Class and the Geometry Execution Model.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Stream Number"
                        }
                    ],
                    "EnablingCapabilities": [
                        "GeometryStreams"
                    ],
                    "Value": "29"
                },
                {
                    "Name": "Location",
                    "Description": "Apply only to a variable or a structure-type member. Location is an unsigned 32-bit integer that forms the main linkage for Storage Class Input and Output variables:\n- between the client API and vertex-stage inputs,\n- between consecutive programmable stages, or\n- between fragment-stage outputs and the client API.\nIt can also tag variables or structure-type members in the UniformConstant Storage Class for linkage with the client API.\nOnly valid for the Input, Output, and UniformConstant Storage Classes.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Location"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "30"
                },
                {
                    "Name": "Component",
                    "Description": "Must only be used on a memory object declaration or a member of a structure type.  Component is an unsigned 32-bit integer indicating which component within a Location is taken by the decorated entity. Only valid for the Input and Output Storage Classes.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Component"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "31"
                },
                {
                    "Name": "Index",
                    "Description": "Apply only to a variable. Index is an unsigned 32-bit integer identifying a blend equation input index, used as specified by the client API. Only valid for the Output Storage Class and the Fragment Execution Model.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Index"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "32"
                },
                {
                    "Name": "Binding",
                    "Description": "Apply only to a variable.Binding Point is an unsigned 32-bit integer forming part of the linkage between the client API and SPIR-V memory buffers, images, etc. See the client API specification for more detail.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Binding Point"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "33"
                },
                {
                    "Name": "DescriptorSet",
                    "Description": "Apply only to a variable.Descriptor Set is an unsigned 32-bit integer forming part of the linkage between the client API and SPIR-V memory buffers, images, etc. See the client API specification for more detail.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Descriptor Set"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "34"
                },
                {
                    "Name": "Offset",
                    "Description": "Apply only to a structure-type member. Byte Offset is an unsigned 32-bit integer.  It dictates the byte offset of the member relative to the beginning of the structure. It can be used, for example, by both uniform and transform-feedback buffers. It must not cause any overlap of the structure\u2019s members, or overflow of a transform-feedback buffer\u2019s XfbStride.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Byte Offset"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "35"
                },
                {
                    "Name": "XfbBuffer",
                    "Description": "Must only be used on a memory object declaration or a member of a structure type.  XFB Buffer is an unsigned 32-bit integer indicating which transform-feedback buffer an output is written to. Only valid for the Output Storage Classes of vertex processing Execution Models.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "XFB Buffer Number"
                        }
                    ],
                    "EnablingCapabilities": [
                        "TransformFeedback"
                    ],
                    "Value": "36"
                },
                {
                    "Name": "XfbStride",
                    "Description": "Apply to anything XfbBuffer is applied to. XFB Stride is an unsigned 32-bit integer specifying the stride, in bytes, of transform-feedback buffer vertices. If the transform-feedback buffer is capturing any double-precision components, the stride must be a multiple of 8, otherwise it must be a multiple of 4.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "XFB Stride"
                        }
                    ],
                    "EnablingCapabilities": [
                        "TransformFeedback"
                    ],
                    "Value": "37"
                },
                {
                    "Name": "FuncParamAttr",
                    "Description": "Indicates a function return value or parameter attribute.",
                    "ExtraOperands": [
                        {
                            "Type": "Function Parameter Attribute",
                            "Description": "Function Parameter Attribute"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "38"
                },
                {
                    "Name": "FPRoundingMode",
                    "Description": "Indicates a floating-point rounding mode.",
                    "ExtraOperands": [
                        {
                            "Type": "FP Rounding Mode",
                            "Description": "Floating-Point Rounding Mode"
                        }
                    ],
                    "Value": "39"
                },
                {
                    "Name": "FPFastMathMode",
                    "Description": "Indicates a floating-point fast math flag.",
                    "ExtraOperands": [
                        {
                            "Type": "FP Fast Math Mode",
                            "Description": "Fast-Math Mode"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "40"
                },
                {
                    "Name": "LinkageAttributes",
                    "Description": "Associate linkage attributes to values. Name is a string specifying what name the Linkage Type applies to. Only valid on OpFunction or global (module scope) OpVariable. See linkage.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Name"
                        },
                        {
                            "Type": "Linkage Type",
                            "Description": "Linkage Type"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Linkage"
                    ],
                    "Value": "41"
                },
                {
                    "Name": "NoContraction",
                    "Description": "Apply only to an arithmetic instruction to indicate the operation cannot be combined with another instruction to form a single operation.  For example, if applied to an OpFMul, that multiply can\u2019t be combined with an addition to yield a fused multiply-add operation. Furthermore, such operations are not allowed to reassociate; e.g., add(a + add(b+c)) cannot be transformed to add(add(a+b) + c).",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "42"
                },
                {
                    "Name": "InputAttachmentIndex",
                    "Description": "Apply only to a variable. Attachment Index is an unsigned 32-bit integer providing an input-target index (as specified by the client API). Only valid in the Fragment Execution Model and for variables of type OpTypeImage  with a Dim operand of SubpassData.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Attachment Index"
                        }
                    ],
                    "EnablingCapabilities": [
                        "InputAttachment"
                    ],
                    "Value": "43"
                },
                {
                    "Name": "Alignment",
                    "Description": "Apply only to a pointer. Alignment is an unsigned 32-bit integer declaring a known minimum alignment the pointer has.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Alignment"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "44"
                },
                {
                    "Name": "MaxByteOffset",
                    "Description": "Apply only to a pointer.Max Byte Offset is an unsigned 32-bit integer declaring a known maximum byte offset this pointer will be incremented by from the point of the decoration. This is a guaranteed upper bound when applied to OpFunctionParameter.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Max Byte Offset"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Addresses"
                    ],
                    "MissingBefore": "1.1",
                    "Value": "45"
                },
                {
                    "Name": "AlignmentId",
                    "Description": "Same as the Alignment decoration, but using an <id> operand instead of a literal. The operand is consumed as unsigned and  must be an integer type scalar.",
                    "ExtraOperands": [
                        {
                            "Type": "<id>",
                            "Description": "Alignment"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MissingBefore": "1.2",
                    "Value": "46"
                },
                {
                    "Name": "MaxByteOffsetId",
                    "Description": "Same as the MaxByteOffset decoration, but using an <id> operand instead of a literal. The operand is consumed as unsigned and  must be an integer type scalar.",
                    "ExtraOperands": [
                        {
                            "Type": "<id>",
                            "Description": "Max Byte Offset"
                        }
                    ],
                    "EnablingCapabilities": [
                        "Addresses"
                    ],
                    "MissingBefore": "1.2",
                    "Value": "47"
                },
                {
                    "Name": "NoSignedWrap",
                    "Description": "Apply to an instruction to indicate that it does not cause signed integer wrapping to occur, in the form of overflow or underflow.\nIt must decorate only the following instructions:\n- OpIAdd\n- OpISub\n- OpIMul\n- OpShiftLeftLogical\n- OpSNegate\n- OpExtInst for instruction numbers specified in the extended instruction-set   specifications as accepting this decoration.\nIf an instruction decorated with NoSignedWrap does overflow or underflow, behavior is undefined.",
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_no_integer_wrap_decoration"
                    ],
                    "Value": "4469"
                },
                {
                    "Name": "NoUnsignedWrap",
                    "Description": "Apply to an instruction to indicate that it does not cause unsigned integer wrapping to occur, in the form of overflow or underflow.\nIt must decorate only the following instructions:\n- OpIAdd\n- OpISub\n- OpIMul\n- OpShiftLeftLogical\n- OpExtInst for instruction numbers specified in the extended instruction-set   specifications as accepting this decoration.\nIf an instruction decorated with NoUnsignedWrap does overflow or underflow, behavior is undefined.",
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_no_integer_wrap_decoration"
                    ],
                    "Value": "4470"
                },
                {
                    "Name": "ExplicitInterpAMD",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_explicit_vertex_parameter"
                    ],
                    "Value": "4999"
                },
                {
                    "Name": "OverrideCoverageNV",
                    "EnablingCapabilities": [
                        "SampleMaskOverrideCoverageNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_sample_mask_override_coverage"
                    ],
                    "Value": "5248"
                },
                {
                    "Name": "PassthroughNV",
                    "EnablingCapabilities": [
                        "GeometryShaderPassthroughNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_geometry_shader_passthrough"
                    ],
                    "Value": "5250"
                },
                {
                    "Name": "ViewportRelativeNV",
                    "EnablingCapabilities": [
                        "ShaderViewportMaskNV"
                    ],
                    "Reserved": true,
                    "Value": "5252"
                },
                {
                    "Name": "SecondaryViewportRelativeNV",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Offset"
                        }
                    ],
                    "EnablingCapabilities": [
                        "ShaderStereoViewNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_stereo_view_rendering"
                    ],
                    "Value": "5256"
                },
                {
                    "Name": "PerPrimitiveNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5271"
                },
                {
                    "Name": "PerViewNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5272"
                },
                {
                    "Name": "PerTaskNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5273"
                },
                {
                    "Name": "PerVertexNV",
                    "EnablingCapabilities": [
                        "FragmentBarycentricNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_fragment_shader_barycentric"
                    ],
                    "Value": "5285"
                },
                {
                    "Name": "NonUniform",
                    "Description": "Apply only to an object. Asserts that the value backing the decorated <id> is not dynamically uniform. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5300"
                },
                {
                    "Name": "NonUniformEXT",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5300"
                },
                {
                    "Name": "RestrictPointer",
                    "Description": "Apply only to an OpVariable, to indicate the compiler may compile as if there is no aliasing of the pointer stored in the variable. See the aliasing section for more detail.",
                    "EnablingCapabilities": [
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer",
                        "SPV_KHR_physical_storage_buffer"
                    ],
                    "Value": "5355"
                },
                {
                    "Name": "RestrictPointerEXT",
                    "EnablingCapabilities": [
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer"
                    ],
                    "Value": "5355"
                },
                {
                    "Name": "AliasedPointer",
                    "Description": "Apply only to an OpVariable, to indicate the compiler is to generate accesses to the pointer stored in the variable that work correctly in the presence of aliasing. See the aliasing section for more detail.",
                    "EnablingCapabilities": [
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer",
                        "SPV_KHR_physical_storage_buffer"
                    ],
                    "Value": "5356"
                },
                {
                    "Name": "AliasedPointerEXT",
                    "EnablingCapabilities": [
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer"
                    ],
                    "Value": "5356"
                },
                {
                    "Name": "ReferencedIndirectlyINTEL",
                    "EnablingCapabilities": [
                        "IndirectReferencesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_function_pointers"
                    ],
                    "Value": "5602"
                },
                {
                    "Name": "CounterBuffer",
                    "Description": "The <id> of a counter buffer associated with the decorated buffer. It must decorate only a variable in the Uniform storage class. Counter Buffer must be a variable in the Uniform storage class.",
                    "ExtraOperands": [
                        {
                            "Type": "<id>",
                            "Description": "Counter Buffer"
                        }
                    ],
                    "MissingBefore": "1.4",
                    "Value": "5634"
                },
                {
                    "Name": "HlslCounterBufferGOOGLE",
                    "ExtraOperands": [
                        {
                            "Type": "<id>",
                            "Description": "Counter Buffer"
                        }
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_GOOGLE_hlsl_functionality1"
                    ],
                    "Value": "5634"
                },
                {
                    "Name": "UserSemantic",
                    "Description": "Semantic is a string describing a user-defined semantic intent of what it decorates. User-defined semantics are case insensitive. It must decorate only a variable or a member of a structure type. If decorating a variable, it must be in the Input or Output storage classes.",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Semantic"
                        }
                    ],
                    "MissingBefore": "1.4",
                    "Value": "5635"
                },
                {
                    "Name": "HlslSemanticGOOGLE",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Semantic"
                        }
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_GOOGLE_hlsl_functionality1"
                    ],
                    "Value": "5635"
                },
                {
                    "Name": "UserTypeGOOGLE",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "User Type"
                        }
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_GOOGLE_user_type"
                    ],
                    "Value": "5636"
                },
                {
                    "Name": "RegisterINTEL",
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5825"
                },
                {
                    "Name": "MemoryINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Memory Type"
                        }
                    ],
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5826"
                },
                {
                    "Name": "NumbanksINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Banks"
                        }
                    ],
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5827"
                },
                {
                    "Name": "BankwidthINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Bank Width"
                        }
                    ],
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5828"
                },
                {
                    "Name": "MaxPrivateCopiesINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Maximum Copies"
                        }
                    ],
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5829"
                },
                {
                    "Name": "SinglepumpINTEL",
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5830"
                },
                {
                    "Name": "DoublepumpINTEL",
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5831"
                },
                {
                    "Name": "MaxReplicatesINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Maximum Replicates"
                        }
                    ],
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5832"
                },
                {
                    "Name": "SimpleDualPortINTEL",
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5833"
                },
                {
                    "Name": "MergeINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Merge Key"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Merge Type"
                        }
                    ],
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5834"
                },
                {
                    "Name": "BankBitsINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Bank Bits"
                        }
                    ],
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5835"
                },
                {
                    "Name": "ForcePow2DepthINTEL",
                    "ExtraOperands": [
                        {
                            "Type": "Literal",
                            "Description": "Force Key"
                        }
                    ],
                    "EnablingCapabilities": [
                        "FPGAMemoryAttributesINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5836"
                }
            ]
        },
        {
            "Name": "BuiltIn",
            "Cases": [
                {
                    "Name": "Position",
                    "Description": "Output vertex position from a vertex processing Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "PointSize",
                    "Description": "Output point size from a vertex processing Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "ClipDistance",
                    "Description": "Array of clip distances. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "ClipDistance"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "CullDistance",
                    "Description": "Array of clip distances. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "CullDistance"
                    ],
                    "Value": "4"
                },
                {
                    "Name": "VertexId",
                    "Description": "Input vertex ID to a Vertex Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "5"
                },
                {
                    "Name": "InstanceId",
                    "Description": "Input instance ID to a Vertex Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "PrimitiveId",
                    "Description": "Primitive ID in a Geometry Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Geometry",
                        "Tessellation",
                        "RayTracingNV",
                        "RayTracingKHR",
                        "MeshShadingNV"
                    ],
                    "Value": "7"
                },
                {
                    "Name": "InvocationId",
                    "Description": "Invocation ID, input to Geometry and TessellationControl Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Geometry",
                        "Tessellation"
                    ],
                    "Value": "8"
                },
                {
                    "Name": "Layer",
                    "Description": "Layer selection for multi-layer framebuffer. See the client API specification for more detail.\nThe Geometry capability allows for a Layer output by a Geometry Execution Model, input to a Fragment Execution Model.\nThe ShaderLayer capability allows for Layer output by a Vertex or Tessellation Execution Model.",
                    "EnablingCapabilities": [
                        "Geometry",
                        "ShaderLayer",
                        "ShaderViewportIndexLayerEXT",
                        "MeshShadingNV"
                    ],
                    "Value": "9"
                },
                {
                    "Name": "ViewportIndex",
                    "Description": "Viewport selection for viewport transformation when using multiple viewports. See the client API specification for more detail.\nThe MultiViewport capability allows for a ViewportIndex output by a Geometry Execution Model, input to a Fragment Execution Model.\nThe ShaderViewportIndex capability allows for a ViewportIndex output by a Vertex or Tessellation Execution Model.",
                    "EnablingCapabilities": [
                        "MultiViewport",
                        "ShaderViewportIndex",
                        "ShaderViewportIndexLayerEXT",
                        "MeshShadingNV"
                    ],
                    "Value": "10"
                },
                {
                    "Name": "TessLevelOuter",
                    "Description": "Output patch outer levels in a TessellationControl Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "11"
                },
                {
                    "Name": "TessLevelInner",
                    "Description": "Output patch inner levels in a TessellationControl Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "12"
                },
                {
                    "Name": "TessCoord",
                    "Description": "Input vertex position in TessellationEvaluation Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "13"
                },
                {
                    "Name": "PatchVertices",
                    "Description": "Input patch vertex count in a tessellation Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "14"
                },
                {
                    "Name": "FragCoord",
                    "Description": "Coordinates (x, y, z, 1/w) of the current fragment, input to the Fragment Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "15"
                },
                {
                    "Name": "PointCoord",
                    "Description": "Coordinates within a point, input to the Fragment Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "16"
                },
                {
                    "Name": "FrontFacing",
                    "Description": "Face direction, input to the Fragment Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "17"
                },
                {
                    "Name": "SampleId",
                    "Description": "Input sample number to the Fragment Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "SampleRateShading"
                    ],
                    "Value": "18"
                },
                {
                    "Name": "SamplePosition",
                    "Description": "Input sample position to the Fragment Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "SampleRateShading"
                    ],
                    "Value": "19"
                },
                {
                    "Name": "SampleMask",
                    "Description": "Input or output sample mask to the Fragment Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "20"
                },
                {
                    "Name": "FragDepth",
                    "Description": "Output fragment depth from the Fragment Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "22"
                },
                {
                    "Name": "HelperInvocation",
                    "Description": "Input whether a helper invocation, to the Fragment Execution Model. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "23"
                },
                {
                    "Name": "NumWorkgroups",
                    "Description": "Number of workgroups in GLCompute or Kernel  Execution Models. See the client API specification for more detail.",
                    "Value": "24"
                },
                {
                    "Name": "WorkgroupSize",
                    "Description": "Work-group size in GLCompute or Kernel  Execution Models. See the client API specification for more detail.",
                    "Value": "25"
                },
                {
                    "Name": "WorkgroupId",
                    "Description": "Work-group ID in GLCompute or Kernel  Execution Models. See the client API specification for more detail.",
                    "Value": "26"
                },
                {
                    "Name": "LocalInvocationId",
                    "Description": "Local invocation ID in GLCompute or Kernel  Execution Models. See the client API specification for more detail.",
                    "Value": "27"
                },
                {
                    "Name": "GlobalInvocationId",
                    "Description": "Global invocation ID in GLCompute or Kernel  Execution Models. See the client API specification for more detail.",
                    "Value": "28"
                },
                {
                    "Name": "LocalInvocationIndex",
                    "Description": "Local invocation index in GLCompute Execution Models. See the client API specification for more detail.\nWork-group Linear ID in Kernel Execution Models. See the client API specification for more detail.",
                    "Value": "29"
                },
                {
                    "Name": "WorkDim",
                    "Description": "Work dimensions in Kernel Execution Models. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "30"
                },
                {
                    "Name": "GlobalSize",
                    "Description": "Global size in Kernel Execution Models. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "31"
                },
                {
                    "Name": "EnqueuedWorkgroupSize",
                    "Description": "Enqueued work-group size in Kernel Execution Models. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "32"
                },
                {
                    "Name": "GlobalOffset",
                    "Description": "Global offset in Kernel Execution Models. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "33"
                },
                {
                    "Name": "GlobalLinearId",
                    "Description": "Global linear ID in Kernel Execution Models. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "34"
                },
                {
                    "Name": "SubgroupSize",
                    "Description": "Subgroup size. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel",
                        "GroupNonUniform",
                        "SubgroupBallotKHR"
                    ],
                    "Value": "36"
                },
                {
                    "Name": "SubgroupMaxSize",
                    "Description": "Subgroup maximum size in Kernel Execution Models. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "37"
                },
                {
                    "Name": "NumSubgroups",
                    "Description": "Number of subgroups in GLCompute or Kernel Execution Models. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel",
                        "GroupNonUniform"
                    ],
                    "Value": "38"
                },
                {
                    "Name": "NumEnqueuedSubgroups",
                    "Description": "Number of enqueued subgroups in Kernel Execution Models. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "39"
                },
                {
                    "Name": "SubgroupId",
                    "Description": "Subgroup ID in GLCompute or Kernel Execution Models. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel",
                        "GroupNonUniform"
                    ],
                    "Value": "40"
                },
                {
                    "Name": "SubgroupLocalInvocationId",
                    "Description": "Subgroup local invocation ID. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Kernel",
                        "GroupNonUniform",
                        "SubgroupBallotKHR"
                    ],
                    "Value": "41"
                },
                {
                    "Name": "VertexIndex",
                    "Description": "Vertex index. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "42"
                },
                {
                    "Name": "InstanceIndex",
                    "Description": "Instance index. See the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "43"
                },
                {
                    "Name": "SubgroupEqMask",
                    "Description": "Subgroup invocations bitmask where bit index == SubgroupLocalInvocationId.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "4416"
                },
                {
                    "Name": "SubgroupGeMask",
                    "Description": "Subgroup invocations bitmask where bit index >= SubgroupLocalInvocationId.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "4417"
                },
                {
                    "Name": "SubgroupGtMask",
                    "Description": "Subgroup invocations bitmask where bit index > SubgroupLocalInvocationId.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "4418"
                },
                {
                    "Name": "SubgroupLeMask",
                    "Description": "Subgroup invocations bitmask where bit index <= SubgroupLocalInvocationId.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "4419"
                },
                {
                    "Name": "SubgroupLtMask",
                    "Description": "Subgroup invocations bitmask where bit index < SubgroupLocalInvocationId.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "4420"
                },
                {
                    "Name": "SubgroupEqMaskKHR",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_shader_ballot"
                    ],
                    "Value": "4416"
                },
                {
                    "Name": "SubgroupGeMaskKHR",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_shader_ballot"
                    ],
                    "Value": "4417"
                },
                {
                    "Name": "SubgroupGtMaskKHR",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_shader_ballot"
                    ],
                    "Value": "4418"
                },
                {
                    "Name": "SubgroupLeMaskKHR",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_shader_ballot"
                    ],
                    "Value": "4419"
                },
                {
                    "Name": "SubgroupLtMaskKHR",
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR",
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_shader_ballot"
                    ],
                    "Value": "4420"
                },
                {
                    "Name": "BaseVertex",
                    "Description": "Base vertex component of vertex ID.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "DrawParameters"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_shader_draw_parameters"
                    ],
                    "Value": "4424"
                },
                {
                    "Name": "BaseInstance",
                    "Description": "Base instance component of instance ID.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "DrawParameters"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_shader_draw_parameters"
                    ],
                    "Value": "4425"
                },
                {
                    "Name": "DrawIndex",
                    "Description": "Contains the index of the draw currently being processed.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "DrawParameters",
                        "MeshShadingNV"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_shader_draw_parameters",
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "4426"
                },
                {
                    "Name": "PrimitiveShadingRateKHR",
                    "EnablingCapabilities": [
                        "FragmentShadingRateKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_fragment_shading_rate"
                    ],
                    "Value": "4432"
                },
                {
                    "Name": "DeviceIndex",
                    "Description": "Input device index of the logical device.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "DeviceGroup"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_device_group"
                    ],
                    "Value": "4438"
                },
                {
                    "Name": "ViewIndex",
                    "Description": "Input view index of the view currently being rendered to.\nSee the client API specification for more detail.",
                    "EnablingCapabilities": [
                        "MultiView"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_multiview"
                    ],
                    "Value": "4440"
                },
                {
                    "Name": "ShadingRateKHR",
                    "EnablingCapabilities": [
                        "FragmentShadingRateKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_fragment_shading_rate"
                    ],
                    "Value": "4444"
                },
                {
                    "Name": "BaryCoordNoPerspAMD",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_explicit_vertex_parameter"
                    ],
                    "Value": "4992"
                },
                {
                    "Name": "BaryCoordNoPerspCentroidAMD",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_explicit_vertex_parameter"
                    ],
                    "Value": "4993"
                },
                {
                    "Name": "BaryCoordNoPerspSampleAMD",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_explicit_vertex_parameter"
                    ],
                    "Value": "4994"
                },
                {
                    "Name": "BaryCoordSmoothAMD",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_explicit_vertex_parameter"
                    ],
                    "Value": "4995"
                },
                {
                    "Name": "BaryCoordSmoothCentroidAMD",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_explicit_vertex_parameter"
                    ],
                    "Value": "4996"
                },
                {
                    "Name": "BaryCoordSmoothSampleAMD",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_explicit_vertex_parameter"
                    ],
                    "Value": "4997"
                },
                {
                    "Name": "BaryCoordPullModelAMD",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_explicit_vertex_parameter"
                    ],
                    "Value": "4998"
                },
                {
                    "Name": "FragStencilRefEXT",
                    "EnablingCapabilities": [
                        "StencilExportEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_shader_stencil_export"
                    ],
                    "Value": "5014"
                },
                {
                    "Name": "ViewportMaskNV",
                    "EnablingCapabilities": [
                        "ShaderViewportMaskNV",
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_viewport_array2",
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5253"
                },
                {
                    "Name": "SecondaryPositionNV",
                    "EnablingCapabilities": [
                        "ShaderStereoViewNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_stereo_view_rendering"
                    ],
                    "Value": "5257"
                },
                {
                    "Name": "SecondaryViewportMaskNV",
                    "EnablingCapabilities": [
                        "ShaderStereoViewNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_stereo_view_rendering"
                    ],
                    "Value": "5258"
                },
                {
                    "Name": "PositionPerViewNV",
                    "EnablingCapabilities": [
                        "PerViewAttributesNV",
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NVX_multiview_per_view_attributes",
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5261"
                },
                {
                    "Name": "ViewportMaskPerViewNV",
                    "EnablingCapabilities": [
                        "PerViewAttributesNV",
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NVX_multiview_per_view_attributes",
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5262"
                },
                {
                    "Name": "FullyCoveredEXT",
                    "EnablingCapabilities": [
                        "FragmentFullyCoveredEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_fully_covered"
                    ],
                    "Value": "5264"
                },
                {
                    "Name": "TaskCountNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5274"
                },
                {
                    "Name": "PrimitiveCountNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5275"
                },
                {
                    "Name": "PrimitiveIndicesNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5276"
                },
                {
                    "Name": "ClipDistancePerViewNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5277"
                },
                {
                    "Name": "CullDistancePerViewNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5278"
                },
                {
                    "Name": "LayerPerViewNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5279"
                },
                {
                    "Name": "MeshViewCountNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5280"
                },
                {
                    "Name": "MeshViewIndicesNV",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5281"
                },
                {
                    "Name": "BaryCoordNV",
                    "EnablingCapabilities": [
                        "FragmentBarycentricNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_fragment_shader_barycentric"
                    ],
                    "Value": "5286"
                },
                {
                    "Name": "BaryCoordNoPerspNV",
                    "EnablingCapabilities": [
                        "FragmentBarycentricNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_fragment_shader_barycentric"
                    ],
                    "Value": "5287"
                },
                {
                    "Name": "FragSizeEXT",
                    "EnablingCapabilities": [
                        "FragmentDensityEXT",
                        "ShadingRateNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_invocation_density",
                        "SPV_NV_shading_rate"
                    ],
                    "Value": "5292"
                },
                {
                    "Name": "FragmentSizeNV",
                    "EnablingCapabilities": [
                        "ShadingRateNV",
                        "FragmentDensityEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shading_rate",
                        "SPV_EXT_fragment_invocation_density"
                    ],
                    "Value": "5292"
                },
                {
                    "Name": "FragInvocationCountEXT",
                    "EnablingCapabilities": [
                        "FragmentDensityEXT",
                        "ShadingRateNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_invocation_density",
                        "SPV_NV_shading_rate"
                    ],
                    "Value": "5293"
                },
                {
                    "Name": "InvocationsPerPixelNV",
                    "EnablingCapabilities": [
                        "ShadingRateNV",
                        "FragmentDensityEXT"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shading_rate",
                        "SPV_EXT_fragment_invocation_density"
                    ],
                    "Value": "5293"
                },
                {
                    "Name": "LaunchIdNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5319"
                },
                {
                    "Name": "LaunchIdKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5319"
                },
                {
                    "Name": "LaunchSizeNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5320"
                },
                {
                    "Name": "LaunchSizeKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5320"
                },
                {
                    "Name": "WorldRayOriginNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5321"
                },
                {
                    "Name": "WorldRayOriginKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5321"
                },
                {
                    "Name": "WorldRayDirectionNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5322"
                },
                {
                    "Name": "WorldRayDirectionKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5322"
                },
                {
                    "Name": "ObjectRayOriginNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5323"
                },
                {
                    "Name": "ObjectRayOriginKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5323"
                },
                {
                    "Name": "ObjectRayDirectionNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5324"
                },
                {
                    "Name": "ObjectRayDirectionKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5324"
                },
                {
                    "Name": "RayTminNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5325"
                },
                {
                    "Name": "RayTminKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5325"
                },
                {
                    "Name": "RayTmaxNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5326"
                },
                {
                    "Name": "RayTmaxKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5326"
                },
                {
                    "Name": "InstanceCustomIndexNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5327"
                },
                {
                    "Name": "InstanceCustomIndexKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5327"
                },
                {
                    "Name": "ObjectToWorldNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5330"
                },
                {
                    "Name": "ObjectToWorldKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5330"
                },
                {
                    "Name": "WorldToObjectNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5331"
                },
                {
                    "Name": "WorldToObjectKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5331"
                },
                {
                    "Name": "HitTNV",
                    "EnablingCapabilities": [
                        "RayTracingNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing"
                    ],
                    "Value": "5332"
                },
                {
                    "Name": "HitKindNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5333"
                },
                {
                    "Name": "HitKindKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5333"
                },
                {
                    "Name": "IncomingRayFlagsNV",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5351"
                },
                {
                    "Name": "IncomingRayFlagsKHR",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5351"
                },
                {
                    "Name": "RayGeometryIndexKHR",
                    "EnablingCapabilities": [
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5352"
                },
                {
                    "Name": "WarpsPerSMNV",
                    "EnablingCapabilities": [
                        "ShaderSMBuiltinsNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_sm_builtins"
                    ],
                    "Value": "5374"
                },
                {
                    "Name": "SMCountNV",
                    "EnablingCapabilities": [
                        "ShaderSMBuiltinsNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_sm_builtins"
                    ],
                    "Value": "5375"
                },
                {
                    "Name": "WarpIDNV",
                    "EnablingCapabilities": [
                        "ShaderSMBuiltinsNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_sm_builtins"
                    ],
                    "Value": "5376"
                },
                {
                    "Name": "SMIDNV",
                    "EnablingCapabilities": [
                        "ShaderSMBuiltinsNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_sm_builtins"
                    ],
                    "Value": "5377"
                }
            ]
        },
        {
            "Name": "Selection Control",
            "Cases": [
                {
                    "Name": "None",
                    "Value": "0x0"
                },
                {
                    "Name": "Flatten",
                    "Description": "Strong request, to the extent possible, to remove the control flow for this selection.",
                    "Value": "0x1"
                },
                {
                    "Name": "DontFlatten",
                    "Description": "Strong request, to the extent possible, to keep this selection as control flow.",
                    "Value": "0x2"
                }
            ]
        },
        {
            "Name": "Loop Control",
            "Cases": [
                {
                    "Name": "None",
                    "Value": "0x0"
                },
                {
                    "Name": "Unroll",
                    "Description": "Strong request, to the extent possible, to unroll or unwind this loop.\nThis must not be used with the DontUnroll bit.",
                    "Value": "0x1"
                },
                {
                    "Name": "DontUnroll",
                    "Description": "Strong request, to the extent possible, to keep this loop as a loop, without unrolling.",
                    "Value": "0x2"
                },
                {
                    "Name": "DependencyInfinite",
                    "Description": "Guarantees that there are no dependencies between loop iterations.",
                    "MissingBefore": "1.1",
                    "Value": "0x4"
                },
                {
                    "Name": "DependencyLength",
                    "Description": "Guarantees that there are no dependencies between a number of loop iterations. The dependency length is specified in a subsequent unsigned 32-bit integer literal operand.",
                    "MissingBefore": "1.1",
                    "Value": "0x8"
                },
                {
                    "Name": "MinIterations",
                    "Description": "Unchecked assertion that the loop executes at least a given number of iterations. The iteration count is specified in a subsequent unsigned 32-bit integer literal operand.",
                    "MissingBefore": "1.4",
                    "Value": "0x10"
                },
                {
                    "Name": "MaxIterations",
                    "Description": "Unchecked assertion that the loop executes at most a given number of iterations. The iteration count is specified in a subsequent unsigned 32-bit integer literal operand.",
                    "MissingBefore": "1.4",
                    "Value": "0x20"
                },
                {
                    "Name": "IterationMultiple",
                    "Description": "Unchecked assertion that the loop executes a multiple of a given number of iterations. The number is specified in a subsequent unsigned 32-bit integer literal operand.  It must be greater than 0.",
                    "MissingBefore": "1.4",
                    "Value": "0x40"
                },
                {
                    "Name": "PeelCount",
                    "Description": "Request that the loop be peeled by a given number of loop iterations. The peel count is specified in a subsequent unsigned 32-bit integer literal operand.\nThis must not be used with the DontUnroll bit.",
                    "MissingBefore": "1.4",
                    "Value": "0x80"
                },
                {
                    "Name": "PartialCount",
                    "Description": "Request that the loop be partially unrolled by a given number of loop iterations. The unroll count is specified in a subsequent unsigned 32-bit integer literal operand.\nThis must not be used with the DontUnroll bit.",
                    "MissingBefore": "1.4",
                    "Value": "0x100"
                },
                {
                    "Name": "InitiationIntervalINTEL",
                    "EnablingCapabilities": [
                        "FPGALoopControlsINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_loop_controls"
                    ],
                    "Value": "0x10000"
                },
                {
                    "Name": "MaxConcurrencyINTEL",
                    "EnablingCapabilities": [
                        "FPGALoopControlsINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_loop_controls"
                    ],
                    "Value": "0x20000"
                },
                {
                    "Name": "DependencyArrayINTEL",
                    "EnablingCapabilities": [
                        "FPGALoopControlsINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_loop_controls"
                    ],
                    "Value": "0x40000"
                },
                {
                    "Name": "PipelineEnableINTEL",
                    "EnablingCapabilities": [
                        "FPGALoopControlsINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_loop_controls"
                    ],
                    "Value": "0x80000"
                },
                {
                    "Name": "LoopCoalesceINTEL",
                    "EnablingCapabilities": [
                        "FPGALoopControlsINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_loop_controls"
                    ],
                    "Value": "0x100000"
                },
                {
                    "Name": "MaxInterleavingINTEL",
                    "EnablingCapabilities": [
                        "FPGALoopControlsINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_loop_controls"
                    ],
                    "Value": "0x200000"
                },
                {
                    "Name": "SpeculatedIterationsINTEL",
                    "EnablingCapabilities": [
                        "FPGALoopControlsINTEL"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_loop_controls"
                    ],
                    "Value": "0x400000"
                }
            ]
        },
        {
            "Name": "Function Control",
            "Cases": [
                {
                    "Name": "None",
                    "Value": "0x0"
                },
                {
                    "Name": "Inline",
                    "Description": "Strong request, to the extent possible, to inline the function.",
                    "Value": "0x1"
                },
                {
                    "Name": "DontInline",
                    "Description": "Strong request, to the extent possible, to not inline the function.",
                    "Value": "0x2"
                },
                {
                    "Name": "Pure",
                    "Description": "Compiler can assume this function has no side effect, but might read global memory or read through dereferenced function parameters. Always computes the same result when called with the same argument values and the same global state.",
                    "Value": "0x4"
                },
                {
                    "Name": "Const",
                    "Description": "Compiler assumes this function has no side effects, and does not access global memory or dereference function parameters. Always computes the same result for the same argument values.",
                    "Value": "0x8"
                }
            ]
        },
        {
            "Name": "Memory Semantics <id>",
            "Cases": [
                {
                    "Name": "None",
                    "Aliases": [
                        "Relaxed"
                    ],
                    "Value": "0x0"
                },
                {
                    "Name": "Acquire",
                    "Description": "On an atomic instruction, orders memory operations provided in program order after this atomic instruction against this atomic instruction. On a barrier, orders memory operations provided in program order after this barrier against atomic instructions before this barrier. See the client API specification for more detail.",
                    "Value": "0x2"
                },
                {
                    "Name": "Release",
                    "Description": "On an atomic instruction, orders memory operations provided in program order before this atomic instruction against this atomic instruction. On a barrier, orders memory operations provided in program order before this barrier against atomic instructions after this barrier. See the client API specification for more detail.",
                    "Value": "0x4"
                },
                {
                    "Name": "AcquireRelease",
                    "Description": "Has the properties of both Acquire and Release semantics.  It is used for read-modify-write operations.",
                    "Value": "0x8"
                },
                {
                    "Name": "SequentiallyConsistent",
                    "Description": "All observers see this memory access in the same order with respect to other sequentially-consistent memory accesses from this invocation.\nIf the declared memory model is Vulkan, SequentiallyConsistent must not be used.",
                    "Value": "0x10"
                },
                {
                    "Name": "UniformMemory",
                    "Description": "Apply the memory-ordering constraints to StorageBuffer, PhysicalStorageBuffer, or Uniform Storage Class memory.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "0x40"
                },
                {
                    "Name": "SubgroupMemory",
                    "Description": "Apply the memory-ordering constraints to subgroup memory.",
                    "Value": "0x80"
                },
                {
                    "Name": "WorkgroupMemory",
                    "Description": "Apply the memory-ordering constraints to Workgroup Storage Class memory.",
                    "Value": "0x100"
                },
                {
                    "Name": "CrossWorkgroupMemory",
                    "Description": "Apply the memory-ordering constraints to CrossWorkgroup Storage Class memory.",
                    "Value": "0x200"
                },
                {
                    "Name": "AtomicCounterMemory",
                    "Description": "Apply the memory-ordering constraints to AtomicCounter Storage Class memory.",
                    "EnablingCapabilities": [
                        "AtomicStorage"
                    ],
                    "Value": "0x400"
                },
                {
                    "Name": "ImageMemory",
                    "Description": "Apply the memory-ordering constraints to image contents (types declared by OpTypeImage), or to accesses done through pointers to the Image Storage Class.",
                    "Value": "0x800"
                },
                {
                    "Name": "OutputMemory",
                    "Description": "Apply the memory-ordering constraints to Output storage class memory.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x1000"
                },
                {
                    "Name": "OutputMemoryKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x1000"
                },
                {
                    "Name": "MakeAvailable",
                    "Description": "Perform an availability operation on all references in the selected storage classes.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x2000"
                },
                {
                    "Name": "MakeAvailableKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x2000"
                },
                {
                    "Name": "MakeVisible",
                    "Description": "Perform a visibility operation on all references in the selected storage classes.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x4000"
                },
                {
                    "Name": "MakeVisibleKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x4000"
                },
                {
                    "Name": "Volatile",
                    "Description": "This access cannot be eliminated, duplicated, or combined with other accesses.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x8000"
                }
            ]
        },
        {
            "Name": "Memory Operands",
            "Cases": [
                {
                    "Name": "None",
                    "Value": "0x0"
                },
                {
                    "Name": "Volatile",
                    "Description": "This access cannot be eliminated, duplicated, or combined with other accesses.",
                    "Value": "0x1"
                },
                {
                    "Name": "Aligned",
                    "Description": "This access has a known alignment. The alignment is specified in a subsequent unsigned 32-bit integer literal operand.  Valid values are defined by the execution environment.",
                    "Value": "0x2"
                },
                {
                    "Name": "Nontemporal",
                    "Description": "Hints that the accessed address is not likely to be accessed again in the near future.",
                    "Value": "0x4"
                },
                {
                    "Name": "MakePointerAvailable",
                    "Description": "Perform an availability operation on the locations pointed to by the pointer operand, after a store. A following operand is the memory scope for the availability operation. Requires NonPrivatePointer to also be set. Not valid with OpLoad.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x8"
                },
                {
                    "Name": "MakePointerAvailableKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x8"
                },
                {
                    "Name": "MakePointerVisible",
                    "Description": "Perform a visibility operation on the locations pointed to by the pointer operand, before a load. A following operand is the memory scope for the visibility operation. Requires NonPrivatePointer to also be set. Not valid with OpStore.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x10"
                },
                {
                    "Name": "MakePointerVisibleKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x10"
                },
                {
                    "Name": "NonPrivatePointer",
                    "Description": "The memory access obeys inter-thread ordering, as specified by the client API.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "0x20"
                },
                {
                    "Name": "NonPrivatePointerKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "0x20"
                }
            ]
        },
        {
            "Name": "Scope <id>",
            "Cases": [
                {
                    "Name": "CrossDevice",
                    "Description": "Scope crosses multiple devices.",
                    "Value": "0"
                },
                {
                    "Name": "Device",
                    "Description": "Scope is the current device.",
                    "Value": "1"
                },
                {
                    "Name": "Workgroup",
                    "Description": "Scope is the current workgroup.",
                    "Value": "2"
                },
                {
                    "Name": "Subgroup",
                    "Description": "Scope is the current subgroup.",
                    "Value": "3"
                },
                {
                    "Name": "Invocation",
                    "Description": "Scope is the current Invocation.",
                    "Value": "4"
                },
                {
                    "Name": "QueueFamily",
                    "Description": "Scope is the current queue family.",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5"
                },
                {
                    "Name": "QueueFamilyKHR",
                    "EnablingCapabilities": [
                        "VulkanMemoryModel"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5"
                },
                {
                    "Name": "ShaderCallKHR",
                    "EnablingCapabilities": [
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "6"
                }
            ]
        },
        {
            "Name": "Group Operation",
            "Cases": [
                {
                    "Name": "Reduce",
                    "Description": "A reduction operation for all values of a specific value X specified by invocations within a workgroup.",
                    "EnablingCapabilities": [
                        "Kernel",
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformBallot"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "InclusiveScan",
                    "Description": "A binary operation with an identity I and n (where n is the size of the workgroup) elements[a0, a1, \u2026 an-1] resulting in [a0, (a0 op a1), \u2026(a0 op a1 op \u2026 op an-1)]",
                    "EnablingCapabilities": [
                        "Kernel",
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformBallot"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "ExclusiveScan",
                    "Description": "A binary operation with an identity I and n (where n is the size of the workgroup) elements[a0, a1, \u2026 an-1] resulting in [I, a0, (a0 op a1), \u2026 (a0 op a1 op \u2026 op an-2)].",
                    "EnablingCapabilities": [
                        "Kernel",
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformBallot"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "ClusteredReduce",
                    "EnablingCapabilities": [
                        "GroupNonUniformClustered"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "3"
                },
                {
                    "Name": "PartitionedReduceNV",
                    "EnablingCapabilities": [
                        "GroupNonUniformPartitionedNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_subgroup_partitioned"
                    ],
                    "Value": "6"
                },
                {
                    "Name": "PartitionedInclusiveScanNV",
                    "EnablingCapabilities": [
                        "GroupNonUniformPartitionedNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_subgroup_partitioned"
                    ],
                    "Value": "7"
                },
                {
                    "Name": "PartitionedExclusiveScanNV",
                    "EnablingCapabilities": [
                        "GroupNonUniformPartitionedNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_subgroup_partitioned"
                    ],
                    "Value": "8"
                }
            ]
        },
        {
            "Name": "Kernel Enqueue Flags",
            "Cases": [
                {
                    "Name": "NoWait",
                    "Description": "Indicates that the enqueued kernels do not need to wait for the parent kernel to finish execution before they begin execution.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0"
                },
                {
                    "Name": "WaitKernel",
                    "Description": "Indicates that all work-items of the parent kernel finish executing and all immediate side effects committed before the enqueued child kernel begins execution.\nNote: Immediate meaning not side effects resulting from child kernels. The side effects would include stores to global memory and pipe reads and writes.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "WaitWorkGroup",
                    "Description": "Indicates that the enqueued kernels wait only for the workgroup that enqueued the kernels to finish before they begin execution.\nNote: This acts as a memory synchronization point between work-items in a work-group and child kernels enqueued by work-items in the work-group.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "2"
                }
            ]
        },
        {
            "Name": "Kernel Profiling Info",
            "Cases": [
                {
                    "Name": "None",
                    "Value": "0x0"
                },
                {
                    "Name": "CmdExecTime",
                    "Description": "Indicates that the profiling info queried is the execution time.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "0x1"
                }
            ]
        },
        {
            "Name": "Capability",
            "Cases": [
                {
                    "Name": "Matrix",
                    "Description": "Uses OpTypeMatrix.",
                    "Value": "0"
                },
                {
                    "Name": "Shader",
                    "Description": "Uses Vertex, Fragment, or GLCompute Execution Models.",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "Value": "1"
                },
                {
                    "Name": "Geometry",
                    "Description": "Uses the Geometry Execution Model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "2"
                },
                {
                    "Name": "Tessellation",
                    "Description": "Uses the TessellationControl or TessellationEvaluation Execution Models.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "3"
                },
                {
                    "Name": "Addresses",
                    "Description": "Uses physical addressing, non-logical addressing modes.",
                    "Value": "4"
                },
                {
                    "Name": "Linkage",
                    "Description": "Uses partially linked modules and libraries.",
                    "Value": "5"
                },
                {
                    "Name": "Kernel",
                    "Description": "Uses the Kernel Execution Model.",
                    "Value": "6"
                },
                {
                    "Name": "Vector16",
                    "Description": "Uses OpTypeVector to declare 8 component or 16 component vectors.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "7"
                },
                {
                    "Name": "Float16Buffer",
                    "Description": "Allows a 16-bit OpTypeFloat instruction for creating an OpTypePointer to a 16-bit float. Pointers to a 16-bit float must not be dereferenced, unless specifically allowed by a specific instruction. All other uses of 16-bit OpTypeFloat are disallowed.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "8"
                },
                {
                    "Name": "Float16",
                    "Description": "Uses OpTypeFloat to declare the 16-bit floating-point type.",
                    "Value": "9"
                },
                {
                    "Name": "Float64",
                    "Description": "Uses OpTypeFloat to declare the 64-bit floating-point type.",
                    "Value": "10"
                },
                {
                    "Name": "Int64",
                    "Description": "Uses OpTypeInt to declare 64-bit integer types.",
                    "Value": "11"
                },
                {
                    "Name": "Int64Atomics",
                    "Description": "Uses atomic instructions on 64-bit integer types.",
                    "EnablingCapabilities": [
                        "Int64"
                    ],
                    "Value": "12"
                },
                {
                    "Name": "ImageBasic",
                    "Description": "Uses OpTypeImage or OpTypeSampler in a Kernel.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "13"
                },
                {
                    "Name": "ImageReadWrite",
                    "Description": "Uses OpTypeImage with the ReadWrite access qualifier in a kernel.",
                    "EnablingCapabilities": [
                        "ImageBasic"
                    ],
                    "Value": "14"
                },
                {
                    "Name": "ImageMipmap",
                    "Description": "Uses non-zero Lod Image Operands in a kernel.",
                    "EnablingCapabilities": [
                        "ImageBasic"
                    ],
                    "Value": "15"
                },
                {
                    "Name": "Pipes",
                    "Description": "Uses OpTypePipe, OpTypeReserveId or pipe instructions.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "17"
                },
                {
                    "Name": "Groups",
                    "Description": "Uses common group instructions.",
                    "SeeExtensions": [
                        "SPV_AMD_shader_ballot"
                    ],
                    "Value": "18"
                },
                {
                    "Name": "DeviceEnqueue",
                    "Description": "Uses OpTypeQueue, OpTypeDeviceEvent, and device side enqueue instructions.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "19"
                },
                {
                    "Name": "LiteralSampler",
                    "Description": "Samplers are made from literals within the module. See OpConstantSampler.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "Value": "20"
                },
                {
                    "Name": "AtomicStorage",
                    "Description": "Uses the AtomicCounter Storage Class, allowing use of only the OpAtomicLoad, OpAtomicIIncrement, and OpAtomicIDecrement instructions.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "21"
                },
                {
                    "Name": "Int16",
                    "Description": "Uses OpTypeInt to declare 16-bit integer types.",
                    "Value": "22"
                },
                {
                    "Name": "TessellationPointSize",
                    "Description": "Tessellation stage exports point size.",
                    "EnablingCapabilities": [
                        "Tessellation"
                    ],
                    "Value": "23"
                },
                {
                    "Name": "GeometryPointSize",
                    "Description": "Geometry stage exports point size",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "24"
                },
                {
                    "Name": "ImageGatherExtended",
                    "Description": "Uses texture gather with non-constant or independent offsets",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "25"
                },
                {
                    "Name": "StorageImageMultisample",
                    "Description": "Uses multi-sample images for non-sampled images.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "27"
                },
                {
                    "Name": "UniformBufferArrayDynamicIndexing",
                    "Description": "Block-decorated arrays in uniform storage classes use dynamically uniform indexing.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "28"
                },
                {
                    "Name": "SampledImageArrayDynamicIndexing",
                    "Description": "Arrays of sampled images, samplers, or images with Sampled = 0 or 1 use dynamically uniform indexing.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "29"
                },
                {
                    "Name": "StorageBufferArrayDynamicIndexing",
                    "Description": "Arrays in the StorageBuffer Storage Class, or BufferBlock-decorated arrays, use dynamically uniform indexing.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "30"
                },
                {
                    "Name": "StorageImageArrayDynamicIndexing",
                    "Description": "Arrays of images with Sampled = 2 are accessed with dynamically uniform indexing.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "31"
                },
                {
                    "Name": "ClipDistance",
                    "Description": "Uses the ClipDistance BuiltIn.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "32"
                },
                {
                    "Name": "CullDistance",
                    "Description": "Uses the CullDistance BuiltIn.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "33"
                },
                {
                    "Name": "ImageCubeArray",
                    "Description": "Uses the Cube Dim with the Arrayed operand in OpTypeImage, with an OpTypeImage having Sampled == 2.",
                    "EnablingCapabilities": [
                        "SampledCubeArray"
                    ],
                    "Value": "34"
                },
                {
                    "Name": "SampleRateShading",
                    "Description": "Uses per-sample rate shading.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "35"
                },
                {
                    "Name": "ImageRect",
                    "Description": "Uses the Rect Dim with an OpTypeImage having Sampled == 2.",
                    "EnablingCapabilities": [
                        "SampledRect"
                    ],
                    "Value": "36"
                },
                {
                    "Name": "SampledRect",
                    "Description": "Uses the Rect Dim with an OpTypeImage having Sampled == 0 or 1.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "37"
                },
                {
                    "Name": "GenericPointer",
                    "Description": "Uses the Generic Storage Class.",
                    "EnablingCapabilities": [
                        "Addresses"
                    ],
                    "Value": "38"
                },
                {
                    "Name": "Int8",
                    "Description": "Uses OpTypeInt to declare 8-bit integer types.",
                    "Value": "39"
                },
                {
                    "Name": "InputAttachment",
                    "Description": "Uses the SubpassData Dim.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "40"
                },
                {
                    "Name": "SparseResidency",
                    "Description": "Uses OpImageSparse\u2026 instructions.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "41"
                },
                {
                    "Name": "MinLod",
                    "Description": "Uses the MinLod Image Operand.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "42"
                },
                {
                    "Name": "Sampled1D",
                    "Description": "Uses the 1D Dim with an OpTypeImage having Sampled == 0 or 1.",
                    "Value": "43"
                },
                {
                    "Name": "Image1D",
                    "Description": "Uses the 1D Dim with an OpTypeImage having Sampled == 2.",
                    "EnablingCapabilities": [
                        "Sampled1D"
                    ],
                    "Value": "44"
                },
                {
                    "Name": "SampledCubeArray",
                    "Description": "Uses the Cube Dim with the Arrayed operand in OpTypeImage, with an OpTypeImage having Sampled == 0 or 1.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "45"
                },
                {
                    "Name": "SampledBuffer",
                    "Description": "Uses the Buffer Dim with an OpTypeImage having Sampled == 0 or 1.",
                    "Value": "46"
                },
                {
                    "Name": "ImageBuffer",
                    "Description": "Uses the Buffer Dim with an OpTypeImage having Sampled == 2.",
                    "EnablingCapabilities": [
                        "SampledBuffer"
                    ],
                    "Value": "47"
                },
                {
                    "Name": "ImageMSArray",
                    "Description": "An MS operand in OpTypeImage indicates multisampled, used with an OpTypeImage having Sampled == 2.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "48"
                },
                {
                    "Name": "StorageImageExtendedFormats",
                    "Description": "One of a large set of more advanced image formats are used, namely one of those in the Image Format table listed as requiring this capability.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "49"
                },
                {
                    "Name": "ImageQuery",
                    "Description": "The sizes, number of samples, or lod, etc. are queried.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "50"
                },
                {
                    "Name": "DerivativeControl",
                    "Description": "Uses fine or coarse-grained derivatives, e.g., OpDPdxFine.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "51"
                },
                {
                    "Name": "InterpolationFunction",
                    "Description": "Uses one of the InterpolateAtCentroid, InterpolateAtSample, or InterpolateAtOffset GLSL.std.450 extended instructions.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "52"
                },
                {
                    "Name": "TransformFeedback",
                    "Description": "Uses the Xfb Execution Mode.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "53"
                },
                {
                    "Name": "GeometryStreams",
                    "Description": "Uses multiple numbered streams for geometry-stage output.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "54"
                },
                {
                    "Name": "StorageImageReadWithoutFormat",
                    "Description": "OpImageRead can use the Unknown Image Format.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "55"
                },
                {
                    "Name": "StorageImageWriteWithoutFormat",
                    "Description": "OpImageWrite can use the Unknown Image Format.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Value": "56"
                },
                {
                    "Name": "MultiViewport",
                    "Description": "Multiple viewports are used.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Value": "57"
                },
                {
                    "Name": "SubgroupDispatch",
                    "Description": "Uses subgroup dispatch instructions.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MissingBefore": "1.1",
                    "Value": "58"
                },
                {
                    "Name": "NamedBarrier",
                    "Description": "Uses OpTypeNamedBarrier.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MissingBefore": "1.1",
                    "Value": "59"
                },
                {
                    "Name": "PipeStorage",
                    "Description": "Uses OpTypePipeStorage.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MissingBefore": "1.1",
                    "Value": "60"
                },
                {
                    "Name": "GroupNonUniform",
                    "MissingBefore": "1.3",
                    "Value": "61"
                },
                {
                    "Name": "GroupNonUniformVote",
                    "EnablingCapabilities": [
                        "GroupNonUniform"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "62"
                },
                {
                    "Name": "GroupNonUniformArithmetic",
                    "EnablingCapabilities": [
                        "GroupNonUniform"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "63"
                },
                {
                    "Name": "GroupNonUniformBallot",
                    "EnablingCapabilities": [
                        "GroupNonUniform"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "64"
                },
                {
                    "Name": "GroupNonUniformShuffle",
                    "EnablingCapabilities": [
                        "GroupNonUniform"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "65"
                },
                {
                    "Name": "GroupNonUniformShuffleRelative",
                    "EnablingCapabilities": [
                        "GroupNonUniform"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "66"
                },
                {
                    "Name": "GroupNonUniformClustered",
                    "EnablingCapabilities": [
                        "GroupNonUniform"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "67"
                },
                {
                    "Name": "GroupNonUniformQuad",
                    "EnablingCapabilities": [
                        "GroupNonUniform"
                    ],
                    "MissingBefore": "1.3",
                    "Value": "68"
                },
                {
                    "Name": "ShaderLayer",
                    "MissingBefore": "1.5",
                    "Value": "69"
                },
                {
                    "Name": "ShaderViewportIndex",
                    "MissingBefore": "1.5",
                    "Value": "70"
                },
                {
                    "Name": "FragmentShadingRateKHR",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_fragment_shading_rate"
                    ],
                    "Value": "4422"
                },
                {
                    "Name": "SubgroupBallotKHR",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_shader_ballot"
                    ],
                    "Value": "4423"
                },
                {
                    "Name": "DrawParameters",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_shader_draw_parameters"
                    ],
                    "Value": "4427"
                },
                {
                    "Name": "SubgroupVoteKHR",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_subgroup_vote"
                    ],
                    "Value": "4431"
                },
                {
                    "Name": "StorageBuffer16BitAccess",
                    "Description": "Uses 16-bit OpTypeFloat and OpTypeInt instructions for creating scalar, vector, and composite types that become members of a block residing in the StorageBuffer storage class, the PhysicalStorageBuffer storage class, or the Uniform storage class with the BufferBlock decoration.",
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_16bit_storage"
                    ],
                    "Value": "4433"
                },
                {
                    "Name": "StorageUniformBufferBlock16",
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_16bit_storage"
                    ],
                    "Value": "4433"
                },
                {
                    "Name": "UniformAndStorageBuffer16BitAccess",
                    "Description": "Uses 16-bit OpTypeFloat and OpTypeInt instructions for creating scalar, vector, and composite types that become members of a block residing in the StorageBuffer storage class, the PhysicalStorageBuffer storage class, or the Uniform storage class.",
                    "EnablingCapabilities": [
                        "StorageBuffer16BitAccess",
                        "StorageUniformBufferBlock16"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_16bit_storage"
                    ],
                    "Value": "4434"
                },
                {
                    "Name": "StorageUniform16",
                    "EnablingCapabilities": [
                        "StorageBuffer16BitAccess",
                        "StorageUniformBufferBlock16"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_16bit_storage"
                    ],
                    "Value": "4434"
                },
                {
                    "Name": "StoragePushConstant16",
                    "Description": "Uses 16-bit OpTypeFloat and OpTypeInt instructions for creating scalar, vector, and composite types that become members of a block residing in the PushConstant storage class.",
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_16bit_storage"
                    ],
                    "Value": "4435"
                },
                {
                    "Name": "StorageInputOutput16",
                    "Description": "Uses 16-bit OpTypeFloat and OpTypeInt instructions for creating scalar, vector, and composite types that become members of a block residing in the Output storage class.",
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_16bit_storage"
                    ],
                    "Value": "4436"
                },
                {
                    "Name": "DeviceGroup",
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_device_group"
                    ],
                    "Value": "4437"
                },
                {
                    "Name": "MultiView",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_multiview"
                    ],
                    "Value": "4439"
                },
                {
                    "Name": "VariablePointersStorageBuffer",
                    "Description": "Allow variable pointers, each confined to a single Block-decorated struct in the StorageBuffer storage class.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_variable_pointers"
                    ],
                    "Value": "4441"
                },
                {
                    "Name": "VariablePointers",
                    "Description": "Allow variable pointers.",
                    "EnablingCapabilities": [
                        "VariablePointersStorageBuffer"
                    ],
                    "MissingBefore": "1.3",
                    "SeeExtensions": [
                        "SPV_KHR_variable_pointers"
                    ],
                    "Value": "4442"
                },
                {
                    "Name": "AtomicStorageOps",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_shader_atomic_counter_ops"
                    ],
                    "Value": "4445"
                },
                {
                    "Name": "SampleMaskPostDepthCoverage",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_post_depth_coverage"
                    ],
                    "Value": "4447"
                },
                {
                    "Name": "StorageBuffer8BitAccess",
                    "Description": "Uses 8-bit OpTypeInt instructions for creating scalar, vector, and composite types that become members of a block residing in the StorageBuffer storage class or the PhysicalStorageBuffer storage class.",
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_8bit_storage"
                    ],
                    "Value": "4448"
                },
                {
                    "Name": "UniformAndStorageBuffer8BitAccess",
                    "Description": "Uses 8-bit OpTypeInt instructions for creating scalar, vector, and composite types that become members of a block residing in the StorageBuffer storage class, the PhysicalStorageBuffer storage class, or the Uniform storage class.",
                    "EnablingCapabilities": [
                        "StorageBuffer8BitAccess"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_8bit_storage"
                    ],
                    "Value": "4449"
                },
                {
                    "Name": "StoragePushConstant8",
                    "Description": "Uses 8-bit OpTypeInt instructions for creating scalar, vector, and composite types that become members of a block residing in the PushConstant storage class.",
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_8bit_storage"
                    ],
                    "Value": "4450"
                },
                {
                    "Name": "DenormPreserve",
                    "Description": "Uses the DenormPreserve execution mode.",
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4464"
                },
                {
                    "Name": "DenormFlushToZero",
                    "Description": "Uses the DenormFlushToZero execution mode.",
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4465"
                },
                {
                    "Name": "SignedZeroInfNanPreserve",
                    "Description": "Uses the SignedZeroInfNanPreserve execution mode.",
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4466"
                },
                {
                    "Name": "RoundingModeRTE",
                    "Description": "Uses the RoundingModeRTE execution mode.",
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4467"
                },
                {
                    "Name": "RoundingModeRTZ",
                    "Description": "Uses the RoundingModeRTZ execution mode.",
                    "MissingBefore": "1.4",
                    "SeeExtensions": [
                        "SPV_KHR_float_controls"
                    ],
                    "Value": "4468"
                },
                {
                    "Name": "RayQueryProvisionalKHR",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_ray_query"
                    ],
                    "Value": "4471"
                },
                {
                    "Name": "RayQueryKHR",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_ray_query"
                    ],
                    "Value": "4472"
                },
                {
                    "Name": "RayTraversalPrimitiveCullingKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_ray_query",
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "4478"
                },
                {
                    "Name": "RayTracingKHR",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "4479"
                },
                {
                    "Name": "Float16ImageAMD",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_gpu_shader_half_float_fetch"
                    ],
                    "Value": "5008"
                },
                {
                    "Name": "ImageGatherBiasLodAMD",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_texture_gather_bias_lod"
                    ],
                    "Value": "5009"
                },
                {
                    "Name": "FragmentMaskAMD",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_fragment_mask"
                    ],
                    "Value": "5010"
                },
                {
                    "Name": "StencilExportEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_shader_stencil_export"
                    ],
                    "Value": "5013"
                },
                {
                    "Name": "ImageReadWriteLodAMD",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_AMD_shader_image_load_store_lod"
                    ],
                    "Value": "5015"
                },
                {
                    "Name": "Int64ImageEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_shader_image_int64"
                    ],
                    "Value": "5016"
                },
                {
                    "Name": "ShaderClockKHR",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_shader_clock"
                    ],
                    "Value": "5055"
                },
                {
                    "Name": "SampleMaskOverrideCoverageNV",
                    "EnablingCapabilities": [
                        "SampleRateShading"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_sample_mask_override_coverage"
                    ],
                    "Value": "5249"
                },
                {
                    "Name": "GeometryShaderPassthroughNV",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_geometry_shader_passthrough"
                    ],
                    "Value": "5251"
                },
                {
                    "Name": "ShaderViewportIndexLayerEXT",
                    "EnablingCapabilities": [
                        "MultiViewport"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_shader_viewport_index_layer"
                    ],
                    "Value": "5254"
                },
                {
                    "Name": "ShaderViewportIndexLayerNV",
                    "EnablingCapabilities": [
                        "MultiViewport"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_viewport_array2"
                    ],
                    "Value": "5254"
                },
                {
                    "Name": "ShaderViewportMaskNV",
                    "EnablingCapabilities": [
                        "ShaderViewportIndexLayerNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_viewport_array2"
                    ],
                    "Value": "5255"
                },
                {
                    "Name": "ShaderStereoViewNV",
                    "EnablingCapabilities": [
                        "ShaderViewportMaskNV"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_stereo_view_rendering"
                    ],
                    "Value": "5259"
                },
                {
                    "Name": "PerViewAttributesNV",
                    "EnablingCapabilities": [
                        "MultiView"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NVX_multiview_per_view_attributes"
                    ],
                    "Value": "5260"
                },
                {
                    "Name": "FragmentFullyCoveredEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_fully_covered"
                    ],
                    "Value": "5265"
                },
                {
                    "Name": "MeshShadingNV",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_mesh_shader"
                    ],
                    "Value": "5266"
                },
                {
                    "Name": "ImageFootprintNV",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_image_footprint"
                    ],
                    "Value": "5282"
                },
                {
                    "Name": "FragmentBarycentricNV",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_fragment_shader_barycentric"
                    ],
                    "Value": "5284"
                },
                {
                    "Name": "ComputeDerivativeGroupQuadsNV",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_compute_shader_derivatives"
                    ],
                    "Value": "5288"
                },
                {
                    "Name": "FragmentDensityEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_invocation_density",
                        "SPV_NV_shading_rate"
                    ],
                    "Value": "5291"
                },
                {
                    "Name": "ShadingRateNV",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shading_rate",
                        "SPV_EXT_fragment_invocation_density"
                    ],
                    "Value": "5291"
                },
                {
                    "Name": "GroupNonUniformPartitionedNV",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_subgroup_partitioned"
                    ],
                    "Value": "5297"
                },
                {
                    "Name": "ShaderNonUniform",
                    "Description": "Uses the NonUniform decoration on a variable or instruction.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5301"
                },
                {
                    "Name": "ShaderNonUniformEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5301"
                },
                {
                    "Name": "RuntimeDescriptorArray",
                    "Description": "Uses arrays of resources which are sized at run-time.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5302"
                },
                {
                    "Name": "RuntimeDescriptorArrayEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5302"
                },
                {
                    "Name": "InputAttachmentArrayDynamicIndexing",
                    "Description": "Arrays of InputAttachments use dynamically uniform indexing.",
                    "EnablingCapabilities": [
                        "InputAttachment"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5303"
                },
                {
                    "Name": "InputAttachmentArrayDynamicIndexingEXT",
                    "EnablingCapabilities": [
                        "InputAttachment"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5303"
                },
                {
                    "Name": "UniformTexelBufferArrayDynamicIndexing",
                    "Description": "Arrays of SampledBuffers use dynamically uniform indexing.",
                    "EnablingCapabilities": [
                        "SampledBuffer"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5304"
                },
                {
                    "Name": "UniformTexelBufferArrayDynamicIndexingEXT",
                    "EnablingCapabilities": [
                        "SampledBuffer"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5304"
                },
                {
                    "Name": "StorageTexelBufferArrayDynamicIndexing",
                    "Description": "Arrays of ImageBuffers use dynamically uniform indexing.",
                    "EnablingCapabilities": [
                        "ImageBuffer"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5305"
                },
                {
                    "Name": "StorageTexelBufferArrayDynamicIndexingEXT",
                    "EnablingCapabilities": [
                        "ImageBuffer"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5305"
                },
                {
                    "Name": "UniformBufferArrayNonUniformIndexing",
                    "Description": "Block-decorated arrays in uniform storage classes use non-uniform indexing.",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5306"
                },
                {
                    "Name": "UniformBufferArrayNonUniformIndexingEXT",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5306"
                },
                {
                    "Name": "SampledImageArrayNonUniformIndexing",
                    "Description": "Arrays of sampled images use non-uniform indexing.",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5307"
                },
                {
                    "Name": "SampledImageArrayNonUniformIndexingEXT",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5307"
                },
                {
                    "Name": "StorageBufferArrayNonUniformIndexing",
                    "Description": "Arrays in the StorageBuffer storage class or BufferBlock-decorated arrays use non-uniform indexing.",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5308"
                },
                {
                    "Name": "StorageBufferArrayNonUniformIndexingEXT",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5308"
                },
                {
                    "Name": "StorageImageArrayNonUniformIndexing",
                    "Description": "Arrays of non-sampled images use non-uniform indexing.",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5309"
                },
                {
                    "Name": "StorageImageArrayNonUniformIndexingEXT",
                    "EnablingCapabilities": [
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5309"
                },
                {
                    "Name": "InputAttachmentArrayNonUniformIndexing",
                    "Description": "Arrays of InputAttachments use non-uniform indexing.",
                    "EnablingCapabilities": [
                        "InputAttachment",
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5310"
                },
                {
                    "Name": "InputAttachmentArrayNonUniformIndexingEXT",
                    "EnablingCapabilities": [
                        "InputAttachment",
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5310"
                },
                {
                    "Name": "UniformTexelBufferArrayNonUniformIndexing",
                    "Description": "Arrays of SampledBuffers use non-uniform indexing.",
                    "EnablingCapabilities": [
                        "SampledBuffer",
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5311"
                },
                {
                    "Name": "UniformTexelBufferArrayNonUniformIndexingEXT",
                    "EnablingCapabilities": [
                        "SampledBuffer",
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5311"
                },
                {
                    "Name": "StorageTexelBufferArrayNonUniformIndexing",
                    "Description": "Arrays of ImageBuffers use non-uniform indexing.",
                    "EnablingCapabilities": [
                        "ImageBuffer",
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "Value": "5312"
                },
                {
                    "Name": "StorageTexelBufferArrayNonUniformIndexingEXT",
                    "EnablingCapabilities": [
                        "ImageBuffer",
                        "ShaderNonUniform"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_descriptor_indexing"
                    ],
                    "Value": "5312"
                },
                {
                    "Name": "RayTracingNV",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_ray_tracing"
                    ],
                    "Value": "5340"
                },
                {
                    "Name": "VulkanMemoryModel",
                    "Description": "Uses the Vulkan memory model. This capability must be declared if and only if the Vulkan memory model is declared.",
                    "MissingBefore": "1.5",
                    "Value": "5345"
                },
                {
                    "Name": "VulkanMemoryModelKHR",
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "5345"
                },
                {
                    "Name": "VulkanMemoryModelDeviceScope",
                    "Description": "Uses Device scope with any instruction when the Vulkan memory model is declared.",
                    "MissingBefore": "1.5",
                    "Value": "5346"
                },
                {
                    "Name": "VulkanMemoryModelDeviceScopeKHR",
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_KHR_vulkan_memory_model"
                    ],
                    "Value": "5346"
                },
                {
                    "Name": "PhysicalStorageBufferAddresses",
                    "Description": "Uses physical addressing on storage buffers.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer",
                        "SPV_KHR_physical_storage_buffer"
                    ],
                    "Value": "5347"
                },
                {
                    "Name": "PhysicalStorageBufferAddressesEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MissingBefore": "1.5",
                    "SeeExtensions": [
                        "SPV_EXT_physical_storage_buffer"
                    ],
                    "Value": "5347"
                },
                {
                    "Name": "ComputeDerivativeGroupLinearNV",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_compute_shader_derivatives"
                    ],
                    "Value": "5350"
                },
                {
                    "Name": "RayTracingProvisionalKHR",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_KHR_ray_tracing"
                    ],
                    "Value": "5353"
                },
                {
                    "Name": "CooperativeMatrixNV",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_cooperative_matrix"
                    ],
                    "Value": "5357"
                },
                {
                    "Name": "FragmentShaderSampleInterlockEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_shader_interlock"
                    ],
                    "Value": "5363"
                },
                {
                    "Name": "FragmentShaderShadingRateInterlockEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_shader_interlock"
                    ],
                    "Value": "5372"
                },
                {
                    "Name": "ShaderSMBuiltinsNV",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_NV_shader_sm_builtins"
                    ],
                    "Value": "5373"
                },
                {
                    "Name": "FragmentShaderPixelInterlockEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_fragment_shader_interlock"
                    ],
                    "Value": "5378"
                },
                {
                    "Name": "DemoteToHelperInvocationEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_demote_to_helper_invocation"
                    ],
                    "Value": "5379"
                },
                {
                    "Name": "SubgroupShuffleINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_subgroups"
                    ],
                    "Value": "5568"
                },
                {
                    "Name": "SubgroupBufferBlockIOINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_subgroups"
                    ],
                    "Value": "5569"
                },
                {
                    "Name": "SubgroupImageBlockIOINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_subgroups"
                    ],
                    "Value": "5570"
                },
                {
                    "Name": "SubgroupImageMediaBlockIOINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_media_block_io"
                    ],
                    "Value": "5579"
                },
                {
                    "Name": "IntegerFunctions2INTEL",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_shader_integer_functions2"
                    ],
                    "Value": "5584"
                },
                {
                    "Name": "FunctionPointersINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_function_pointers"
                    ],
                    "Value": "5603"
                },
                {
                    "Name": "IndirectReferencesINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_function_pointers"
                    ],
                    "Value": "5604"
                },
                {
                    "Name": "SubgroupAvcMotionEstimationINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_device_side_avc_motion_estimation"
                    ],
                    "Value": "5696"
                },
                {
                    "Name": "SubgroupAvcMotionEstimationIntraINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_device_side_avc_motion_estimation"
                    ],
                    "Value": "5697"
                },
                {
                    "Name": "SubgroupAvcMotionEstimationChromaINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_device_side_avc_motion_estimation"
                    ],
                    "Value": "5698"
                },
                {
                    "Name": "FPGAMemoryAttributesINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_memory_attributes"
                    ],
                    "Value": "5824"
                },
                {
                    "Name": "UnstructuredLoopControlsINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_unstructured_loop_controls"
                    ],
                    "Value": "5886"
                },
                {
                    "Name": "FPGALoopControlsINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_loop_controls"
                    ],
                    "Value": "5888"
                },
                {
                    "Name": "KernelAttributesINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_kernel_attributes"
                    ],
                    "Value": "5892"
                },
                {
                    "Name": "FPGAKernelAttributesINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_kernel_attributes"
                    ],
                    "Value": "5897"
                },
                {
                    "Name": "BlockingPipesINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_blocking_pipes"
                    ],
                    "Value": "5945"
                },
                {
                    "Name": "FPGARegINTEL",
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_INTEL_fpga_reg"
                    ],
                    "Value": "5948"
                },
                {
                    "Name": "AtomicFloat32AddEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_shader_atomic_float_add"
                    ],
                    "Value": "6033"
                },
                {
                    "Name": "AtomicFloat64AddEXT",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "SeeExtensions": [
                        "SPV_EXT_shader_atomic_float_add"
                    ],
                    "Value": "6034"
                }
            ]
        },
        {
            "Name": "Reserved Ray Flags",
            "Cases": [
                {
                    "Name": "None",
                    "Value": "0x0"
                },
                {
                    "Name": "OpaqueKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x1"
                },
                {
                    "Name": "NoOpaqueKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x2"
                },
                {
                    "Name": "TerminateOnFirstHitKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x4"
                },
                {
                    "Name": "SkipClosestHitShaderKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x8"
                },
                {
                    "Name": "CullBackFacingTrianglesKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x10"
                },
                {
                    "Name": "CullFrontFacingTrianglesKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x20"
                },
                {
                    "Name": "CullOpaqueKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x40"
                },
                {
                    "Name": "CullNoOpaqueKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x80"
                },
                {
                    "Name": "SkipTrianglesKHR",
                    "EnablingCapabilities": [
                        "RayTraversalPrimitiveCullingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x100"
                },
                {
                    "Name": "SkipAABBsKHR",
                    "EnablingCapabilities": [
                        "RayTraversalPrimitiveCullingKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x200"
                }
            ]
        },
        {
            "Name": "Reserved Ray Query Intersection",
            "Cases": [
                {
                    "Name": "RayQueryCandidateIntersectionKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "Value": "0"
                },
                {
                    "Name": "RayQueryCommittedIntersectionKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "Value": "1"
                }
            ]
        },
        {
            "Name": "Reserved Ray Query Committed Type",
            "Cases": [
                {
                    "Name": "RayQueryCommittedIntersectionNoneKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "Value": "0"
                },
                {
                    "Name": "RayQueryCommittedIntersectionTriangleKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "Value": "1"
                },
                {
                    "Name": "RayQueryCommittedIntersectionGeneratedKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "Value": "2"
                }
            ]
        },
        {
            "Name": "Reserved Ray Query Candidate Type",
            "Cases": [
                {
                    "Name": "RayQueryCandidateIntersectionTriangleKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "Value": "0"
                },
                {
                    "Name": "RayQueryCandidateIntersectionAABBKHR",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "Value": "1"
                }
            ]
        },
        {
            "Name": "Reserved Fragment Shading Rate",
            "Cases": [
                {
                    "Name": "None",
                    "Value": "0x0"
                },
                {
                    "Name": "Vertical2Pixels",
                    "EnablingCapabilities": [
                        "FragmentShadingRateKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x1"
                },
                {
                    "Name": "Vertical4Pixels",
                    "EnablingCapabilities": [
                        "FragmentShadingRateKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x2"
                },
                {
                    "Name": "Horizontal2Pixels",
                    "EnablingCapabilities": [
                        "FragmentShadingRateKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x4"
                },
                {
                    "Name": "Horizontal4Pixels",
                    "EnablingCapabilities": [
                        "FragmentShadingRateKHR"
                    ],
                    "Reserved": true,
                    "Value": "0x8"
                }
            ]
        }
    ],
    "InstructionClasses": [
        {
            "Name": "Miscellaneous Instructions",
            "Instructions": [
                {
                    "Name": "OpNop",
                    "Description": "This has no semantic impact and can safely be removed from a module.",
                    "MinWordCount": 1,
                    "Opcode": 0
                },
                {
                    "Name": "OpUndef",
                    "Description": "Make an intermediate object whose value is undefined.\nResult Type is the type of object to make.\nEach consumption of Result <id> yields an arbitrary, possibly different bit pattern or abstract value resulting in possibly different concrete, abstract, or opaque values.",
                    "MinWordCount": 3,
                    "Opcode": 1,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpSizeOf",
                    "Description": "Computes the run-time size of the type pointed to by Pointer\nResult Type must be a 32-bit integer type scalar.\nPointer must point to a concrete type.",
                    "EnablingCapabilities": [
                        "Addresses"
                    ],
                    "MissingBefore": "1.1",
                    "MinWordCount": 4,
                    "Opcode": 321,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Debug Instructions",
            "Instructions": [
                {
                    "Name": "OpSourceContinued",
                    "Description": "Continue specifying the Source text from the previous instruction. This has no semantic impact and can safely be removed from a module.\nContinued Source is a continuation of the source text in the previous Source.\nThe previous instruction must be an OpSource or an OpSourceContinued instruction. As is true for all literal strings, the previous instruction\u2019s string was nul terminated. That terminating nul from the previous instruction is not part of the source text; the first character of Continued Source logically immediately follows the last character of Source before its nul.",
                    "MinWordCount": 2,
                    "VariableWordCount": true,
                    "Opcode": 2,
                    "Operands": [
                        {
                            "Type": "Literal",
                            "Description": "Continued Source"
                        }
                    ]
                },
                {
                    "Name": "OpSource",
                    "Description": "Document what source language and text this module was translated from. This has no semantic impact and can safely be removed from a module.\nVersion is the version of the source language. It is an unsigned 32-bit integer.\nFile is an OpString instruction and is the source-level file name.\nSource is the text of the source-level file.\nEach client API specifies what form the Version operand takes, per source language.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 3,
                    "Operands": [
                        {
                            "Type": "Source Language"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Version"
                        },
                        {
                            "Type": "<id>",
                            "Description": "File",
                            "Optional": true
                        },
                        {
                            "Type": "Literal",
                            "Description": "Source",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpSourceExtension",
                    "Description": "Document an extension to the source language. This has no semantic impact and can safely be removed from a module.\nExtension is a string describing a source-language extension. Its form is dependent on the how the source language describes extensions.",
                    "MinWordCount": 2,
                    "VariableWordCount": true,
                    "Opcode": 4,
                    "Operands": [
                        {
                            "Type": "Literal",
                            "Description": "Extension"
                        }
                    ]
                },
                {
                    "Name": "OpName",
                    "Description": "Assign a name string to another instruction\u2019s Result <id>. This has no semantic impact and can safely be removed from a module.\nTarget is the Result <id> to assign a name to. It can be the Result <id> of any other instruction; a variable, function, type, intermediate result, etc.\nName is the string to assign.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 5,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Target"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Name"
                        }
                    ]
                },
                {
                    "Name": "OpMemberName",
                    "Description": "Assign a name string to a member of a structure type. This has no semantic impact and can safely be removed from a module.\nType is the <id> from an OpTypeStruct instruction.\nMember is the number of the member to assign in the structure. The first member is member 0, the next is member 1, \u2026 Member is an unsigned 32-bit integer.\nName is the string to assign to the member.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 6,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Type"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Member"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Name"
                        }
                    ]
                },
                {
                    "Name": "OpString",
                    "Description": "Assign a Result <id> to a string for use by other debug instructions (see OpLine and OpSource). This has no semantic impact and can safely be removed from a module. (Removal also requires removal of all instructions referencing Result <id>.)\nString is the string being assigned a Result <id>.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 7,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Literal",
                            "Description": "String"
                        }
                    ]
                },
                {
                    "Name": "OpLine",
                    "Description": "Add source-level location information. This has no semantic impact and can safely be removed from a module.\nThis location information applies to the instructions physically following this instruction, up to the first occurrence of any of the following: the next end of block, the next OpLine instruction, or the next OpNoLine instruction.\nFile must be an OpString instruction and is the source-level file name.\nLine is the source-level line number. Line is an unsigned 32-bit integer.\nColumn is the source-level column number. Column is an unsigned 32-bit integer.\nOpLine can generally immediately precede other instructions, with the following exceptions:\n- it may not be used until after the annotation instructions,\n(see the Logical Layout section)\n- must not be the last instruction in a block, which is defined to end with a termination instruction\n- if a branch merge instruction is used, the last OpLine in the block must be before its merge instruction",
                    "MinWordCount": 4,
                    "Opcode": 8,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "File"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Line"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Column"
                        }
                    ]
                },
                {
                    "Name": "OpNoLine",
                    "Description": "Discontinue any source-level location information that might be active from a previous OpLine instruction. This has no semantic impact and can safely be removed from a module.\nThis instruction must only appear after the annotation instructions (see the Logical Layout section). It must not be the last instruction in a block, or the second-to-last instruction if the block has a merge instruction. There is not a requirement that there is a preceding OpLine instruction.",
                    "MinWordCount": 1,
                    "Opcode": 317
                },
                {
                    "Name": "OpModuleProcessed",
                    "Description": "Document a process that was applied to a module. This has no semantic impact and can safely be removed from a module.\nProcess is a string describing a process and/or tool (processor) that did the processing. Its form is dependent on the processor.",
                    "MissingBefore": "1.1",
                    "MinWordCount": 2,
                    "VariableWordCount": true,
                    "Opcode": 330,
                    "Operands": [
                        {
                            "Type": "Literal",
                            "Description": "Process"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Annotation Instructions",
            "Instructions": [
                {
                    "Name": "OpDecorate",
                    "Description": "Add a Decoration to another <id>.\nTarget is the <id> to decorate.  It can potentially be any <id> that is a forward reference. A set of decorations can be grouped together by having multiple decoration instructions targeting the same OpDecorationGroup instruction.\nThis instruction is only valid if the Decoration operand is a decoration that takes no Extra Operands, or takes Extra Operands that are not <id> operands.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 71,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Target"
                        },
                        {
                            "Type": "Decoration"
                        },
                        {
                            "Type": "Literal",
                            "Description": "See Decoration.",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpMemberDecorate",
                    "Description": "Add a Decoration to a member of a structure type.\nStructure type is the <id> of a type from OpTypeStruct.\nMember is the number of the member to decorate in the type. The first member is member 0, the next is member 1, \u2026\nNote: See OpDecorate for creating groups of decorations for consumption by OpGroupMemberDecorate",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 72,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Structure Type"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Member"
                        },
                        {
                            "Type": "Decoration"
                        },
                        {
                            "Type": "Literal",
                            "Description": "See Decoration.",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpDecorationGroup",
                    "Description": "Deprecated (directly use non-group decoration instructions instead).\nA collector for Decorations from OpDecorate and OpDecorateId instructions. All such decoration instructions targeting this OpDecorationGroup instruction must precede it. Subsequent OpGroupDecorate and OpGroupMemberDecorate instructions that consume this instruction\u2019s Result <id> will apply these decorations to their targets.",
                    "MinWordCount": 2,
                    "Opcode": 73,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpGroupDecorate",
                    "Description": "Deprecated (directly use non-group decoration instructions instead).\nAdd a group of Decorations to another <id>.\nDecoration Group is the <id> of an OpDecorationGroup instruction.\nTargets is a list of <id>s to decorate with the groups of decorations. The Targets list must not include the <id> of any OpDecorationGroup instruction.",
                    "MinWordCount": 2,
                    "VariableWordCount": true,
                    "Opcode": 74,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Decoration Group"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Targets",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupMemberDecorate",
                    "Description": "Deprecated (directly use non-group decoration instructions instead).\nAdd a group of Decorations to members of structure types.\nDecoration Group is the <id> of an OpDecorationGroup instruction.\nTargets is a list of (<id>, Member) pairs to decorate with the groups of decorations. Each <id> in the pair must be a target structure type, and the associated Member is the number of the member to decorate in the type. The first member is member 0, the next is member 1, \u2026",
                    "MinWordCount": 2,
                    "VariableWordCount": true,
                    "Opcode": 75,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Decoration Group"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Targets",
                            "Listed": true
                        },
                        {
                            "Type": "Literal",
                            "Description": "Targets",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpDecorateId",
                    "Description": "Add a Decoration to another <id>, using <id>s as Extra Operands.\nTarget is the <id> to decorate.  It can potentially be any <id> that is a forward reference. A set of decorations can be grouped together by having multiple decoration instructions targeting the same OpDecorationGroup instruction.\nThis instruction is only valid if the Decoration operand is a decoration that takes Extra Operands that are <id> operands. All such <id> Extra Operands must be constant instructions or OpVariable instructions.",
                    "MissingBefore": "1.2",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 332,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Target"
                        },
                        {
                            "Type": "Decoration"
                        },
                        {
                            "Type": "<id>",
                            "Description": "See Decoration.",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpDecorateString",
                    "Aliases": [
                        "OpDecorateStringGOOGLE"
                    ],
                    "Description": "Add a string Decoration to another <id>.\nTarget is the <id> to decorate.  It can potentially be any <id> that is a forward reference,  except it must not be the <id> of an OpDecorationGroup.\nDecoration is a decoration that takes at least one Literal operand, and has only Literal string operands.",
                    "MissingBefore": "1.4",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 5632,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Target"
                        },
                        {
                            "Type": "Decoration"
                        },
                        {
                            "Type": "Literal",
                            "Description": "See Decoration."
                        },
                        {
                            "Type": "See Decoration.",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpMemberDecorateString",
                    "Aliases": [
                        "OpMemberDecorateStringGOOGLE"
                    ],
                    "Description": "Add a string Decoration to a member of a structure type.\nStructure Type is the <id> of an OpTypeStruct.\nMember is the number of the member to decorate in the type. Member is an unsigned 32-bit integer.  The first member is member 0, the next is member 1, \u2026\nDecoration is a decoration that takes at least one Literal operand, and has only Literal string operands.",
                    "MissingBefore": "1.4",
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 5633,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Struct Type"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Member"
                        },
                        {
                            "Type": "Decoration"
                        },
                        {
                            "Type": "Literal",
                            "Description": "See Decoration."
                        },
                        {
                            "Type": "See Decoration.",
                            "Optional": true
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Extension Instructions",
            "Instructions": [
                {
                    "Name": "OpExtension",
                    "Description": "Declare use of an extension to SPIR-V. This allows validation of additional instructions, tokens, semantics, etc.\nName is the extension\u2019s name string.",
                    "MinWordCount": 2,
                    "VariableWordCount": true,
                    "Opcode": 10,
                    "Operands": [
                        {
                            "Type": "Literal",
                            "Description": "Name"
                        }
                    ]
                },
                {
                    "Name": "OpExtInstImport",
                    "Description": "Import an extended set of instructions. It can be later referenced by the Result <id>.\nName is the extended instruction-set\u2019s name string. An external specification defines the semantics for this extended instruction set.\nSee Extended Instruction Sets for more information.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 11,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Name"
                        }
                    ]
                },
                {
                    "Name": "OpExtInst",
                    "Description": "Execute an instruction in an imported set of extended instructions.\nResult Type is defined, per Instruction, in the external specification for Set.\nSet is the result of an OpExtInstImport instruction.\nInstruction is the enumerant of the instruction to execute within Set. It is an unsigned 32-bit integer.  The semantics of the instruction are defined in the external specification for Set.\nOperand 1, \u2026 are the operands to the extended instruction.",
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 12,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Set"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Instruction"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand",
                            "Listed": true
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Mode-Setting Instructions",
            "Instructions": [
                {
                    "Name": "OpMemoryModel",
                    "Description": "Set addressing model and memory model for the entire module.\nAddressing Model selects the module\u2019s Addressing Model.\nMemory Model selects the module\u2019s memory model, see Memory Model.",
                    "MinWordCount": 3,
                    "Opcode": 14,
                    "Operands": [
                        {
                            "Type": "Addressing Model"
                        },
                        {
                            "Type": "Memory Model"
                        }
                    ]
                },
                {
                    "Name": "OpEntryPoint",
                    "Description": "Declare an entry point, its execution model, and its interface.\nExecution Model is the execution model for the entry point and its static call tree. See Execution Model.\nEntry Point must be the Result <id> of an OpFunction instruction.\nName is a name string for the entry point. A module must not have two OpEntryPoint instructions with the same Execution Model and the same Name string.\nInterface is a list of <id> of global OpVariable instructions. These declare the set of global variables from a module that form the interface of this entry point. The set of Interface <id> must be equal to or a superset of the global OpVariable Result <id> referenced by the entry point\u2019s static call tree, within the interface\u2019s storage classes. Before version 1.4, the interface\u2019s storage classes are limited to the Input and Output storage classes. Starting with version 1.4, the interface\u2019s storage classes are all storage classes used in declaring all global variables referenced by the entry point\u2019s call tree.\nInterface <id> are forward references. Before version 1.4, duplication of these <id> is tolerated. Starting with version 1.4, an <id> must not appear more than once.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 15,
                    "Operands": [
                        {
                            "Type": "Execution Model"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Entry Point"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Name"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Interface",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpExecutionMode",
                    "Description": "Declare an execution mode for an entry point.\nEntry Point must be the Entry Point <id> operand of an OpEntryPoint instruction.\nMode is the execution mode. See Execution Mode.\nThis instruction is only valid if the Mode operand is an execution mode that takes no Extra Operands, or takes Extra Operands that are not <id> operands.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 16,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Entry Point"
                        },
                        {
                            "Type": "Execution Mode",
                            "Description": "Mode"
                        },
                        {
                            "Type": "Literal",
                            "Description": "See Execution Mode",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpCapability",
                    "Description": "Declare a capability used by this module.\nCapability is the capability declared by this instruction.  There are no restrictions on the order in which capabilities are declared.\nSee the capabilities section for more detail.",
                    "MinWordCount": 2,
                    "Opcode": 17,
                    "Operands": [
                        {
                            "Type": "Capability",
                            "Description": "Capability"
                        }
                    ]
                },
                {
                    "Name": "OpExecutionModeId",
                    "Description": "Declare an execution mode for an entry point, using <id>s as Extra Operands.\nEntry Point must be the Entry Point <id> operand of an OpEntryPoint instruction.\nMode is the execution mode. See Execution Mode.\nThis instruction is only valid if the Mode operand is an execution mode that takes Extra Operands that are <id> operands. All such <id> Extra Operands must be constant instructions.",
                    "MissingBefore": "1.2",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 331,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Entry Point"
                        },
                        {
                            "Type": "Execution Mode",
                            "Description": "Mode"
                        },
                        {
                            "Type": "<id>",
                            "Description": "See Execution Mode",
                            "Listed": true
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Type-Declaration Instructions",
            "Instructions": [
                {
                    "Name": "OpTypeVoid",
                    "Description": "Declare the void type.",
                    "MinWordCount": 2,
                    "Opcode": 19,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpTypeBool",
                    "Description": "Declare the Boolean type.  Values of this type can only be either true or false. There is no physical size or bit pattern defined for these values.  If they are stored (in conjunction with OpVariable), they must only be used with logical addressing operations, not physical, and only with non-externally visible shader Storage Classes: Workgroup, CrossWorkgroup, Private, Function, Input, and Output.",
                    "MinWordCount": 2,
                    "Opcode": 20,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpTypeInt",
                    "Description": "Declare a new integer type.\nWidth specifies how many bits wide the type is. Width is an unsigned 32-bit integer.  The bit pattern of a signed integer value is two\u2019s complement.\nSignedness specifies whether there are signed semantics to preserve or validate.\n0 indicates unsigned, or no signedness semantics\n1 indicates signed semantics.\nIn all cases, the type of operation of an instruction comes from the instruction\u2019s opcode, not the signedness of the operands.",
                    "MinWordCount": 4,
                    "Opcode": 21,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Width"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Signedness"
                        }
                    ]
                },
                {
                    "Name": "OpTypeFloat",
                    "Description": "Declare a new floating-point type.\nWidth specifies how many bits wide the type is. Width is an unsigned 32-bit integer.  The bit pattern of a floating-point value is as described by the IEEE 754 standard.",
                    "MinWordCount": 3,
                    "Opcode": 22,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Width"
                        }
                    ]
                },
                {
                    "Name": "OpTypeVector",
                    "Description": "Declare a new vector type.\nComponent Type is the type of each component in the resulting type.  It must be a scalar type.\nComponent Count is the number of components in the resulting type. Component Count is an unsigned 32-bit integer.  It must be at least 2.\nComponents are numbered consecutively, starting with 0.",
                    "MinWordCount": 4,
                    "Opcode": 23,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Component Type"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Component Count"
                        }
                    ]
                },
                {
                    "Name": "OpTypeMatrix",
                    "Description": "Declare a new matrix type.\nColumn Type is the type of each column in the matrix.  It must be vector type.\nColumn Count is the number of columns in the new matrix type. Column Count is an unsigned 32-bit integer.  It must be at least 2.\nMatrix columns are numbered consecutively, starting with 0. This is true independently of any Decorations describing the memory layout of a matrix (e.g., RowMajor or MatrixStride).",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 24,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Column Type"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Column Count"
                        }
                    ]
                },
                {
                    "Name": "OpTypeImage",
                    "Description": "Declare a new image type. Consumed, for example, by OpTypeSampledImage. This type is opaque: values of this type have no defined physical size or bit pattern.\nSampled Type is the type of the components that result from sampling or reading from this image type. Must be a scalar numerical type or OpTypeVoid.\nDim is the image dimensionality (Dim).\nAll the following literals are integers taking one operand each.\nDepth is whether or not this image is a depth image. (Note that whether or not depth comparisons are actually done is a property of the sampling opcode, not of this type declaration.)\n0 indicates not a depth image\n1 indicates a depth image\n2 means no indication as to whether this is a depth or non-depth image\nArrayed must be one of the following indicated values:\n0 indicates non-arrayed content\n1 indicates arrayed content\nMS must be one of the following indicated values:\n0 indicates single-sampled content\n1 indicates multisampled content\nSampled indicates whether or not this image is accessed in combination with a sampler, and must be one of the following values:\n0 indicates this is only known at run time, not at compile time\n1 indicates used with sampler\n2 indicates used without a sampler (a storage image)\nImage Format is the Image Format, which can be Unknown, as specified by the client API.\nIf Dim is SubpassData, Sampled must be 2, Image Format must be Unknown, and the Execution Model must be Fragment.\nAccess Qualifier is an image Access Qualifier.",
                    "MinWordCount": 9,
                    "VariableWordCount": true,
                    "Opcode": 25,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Type"
                        },
                        {
                            "Type": "Dim"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Depth"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Arrayed"
                        },
                        {
                            "Type": "Literal",
                            "Description": "MS"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Sampled"
                        },
                        {
                            "Type": "Image Format"
                        },
                        {
                            "Type": "Access Qualifier",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpTypeSampler",
                    "Description": "Declare the sampler type. Consumed by OpSampledImage. This type is opaque: values of this type have no defined physical size or bit pattern.",
                    "MinWordCount": 2,
                    "Opcode": 26,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpTypeSampledImage",
                    "Description": "Declare a sampled image type, the Result Type of OpSampledImage, or an externally combined sampler and image. This type is opaque: values of this type have no defined physical size or bit pattern.\nImage Type must be an OpTypeImage.  It is the type of the image in the combined sampler and image type.",
                    "MinWordCount": 3,
                    "Opcode": 27,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image Type"
                        }
                    ]
                },
                {
                    "Name": "OpTypeArray",
                    "Description": "Declare a new array type.\nElement Type is the type of each element in the array.\nLength is the number of elements in the array.  It must be at least 1. Length must come from a constant instruction of an integer-type scalar whose value is at least 1.\nArray elements are numbered consecutively, starting with 0.",
                    "MinWordCount": 4,
                    "Opcode": 28,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Element Type"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Length"
                        }
                    ]
                },
                {
                    "Name": "OpTypeRuntimeArray",
                    "Description": "Declare a new run-time array type.  Its length is not known at compile time.\nElement Type is the type of each element in the array.\nSee OpArrayLength for getting the Length of an array of this type.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 3,
                    "Opcode": 29,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Element Type"
                        }
                    ]
                },
                {
                    "Name": "OpTypeStruct",
                    "Description": "Declare a new structure type.\nMember N type is the type of member N of the structure. The first member is member 0, the next is member 1, \u2026 It is valid for the structure to have no members.\nIf an operand is not yet defined, it must be defined by an OpTypePointer, where the type pointed to is an OpTypeStruct.",
                    "MinWordCount": 2,
                    "VariableWordCount": true,
                    "Opcode": 30,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Member type",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpTypeOpaque",
                    "Description": "Declare a structure type with no body specified.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 31,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Literal",
                            "Description": "The name of the opaque type."
                        }
                    ]
                },
                {
                    "Name": "OpTypePointer",
                    "Description": "Declare a new pointer type.\nStorage Class is the Storage Class of the memory holding the object pointed to. If there was a forward reference to this type from an OpTypeForwardPointer, the Storage Class of that instruction must equal the Storage Class of this instruction.\nType is the type of the object pointed to.",
                    "MinWordCount": 4,
                    "Opcode": 32,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Storage Class"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Type"
                        }
                    ]
                },
                {
                    "Name": "OpTypeFunction",
                    "Description": "Declare a new function type.\nOpFunction uses this to declare the return type and parameter types of a function.\nReturn Type is the type of the return value of functions of this type. It must be a concrete or abstract type, or a pointer to such a type. If the function has no return value, Return Type must be OpTypeVoid.\nParameter N Type is the type <id> of the type of parameter N. It must not be OpTypeVoid",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 33,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Return Type"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Parameter Type",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpTypeEvent",
                    "Description": "Declare an OpenCL event type.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 2,
                    "Opcode": 34,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpTypeDeviceEvent",
                    "Description": "Declare an OpenCL device-side event type.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 2,
                    "Opcode": 35,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpTypeReserveId",
                    "Description": "Declare an OpenCL reservation id type.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 2,
                    "Opcode": 36,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpTypeQueue",
                    "Description": "Declare an OpenCL queue type.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 2,
                    "Opcode": 37,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpTypePipe",
                    "Description": "Declare an OpenCL pipe type.\nQualifier is the pipe access qualifier.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 3,
                    "Opcode": 38,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Access Qualifier",
                            "Description": "Qualifier"
                        }
                    ]
                },
                {
                    "Name": "OpTypeForwardPointer",
                    "Description": "Declare the storage class for a forward reference to a pointer.\nPointer Type is a forward reference to the result of an OpTypePointer. That OpTypePointer instruction must declare Pointer Type to be a pointer to an OpTypeStruct. Any consumption of Pointer Type before its OpTypePointer declaration must be a type-declaration instruction.\nStorage Class is the Storage Class of the memory holding the object pointed to.",
                    "EnablingCapabilities": [
                        "Addresses",
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MinWordCount": 3,
                    "Opcode": 39,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Pointer Type"
                        },
                        {
                            "Type": "Storage Class"
                        }
                    ]
                },
                {
                    "Name": "OpTypePipeStorage",
                    "Description": "Declare the OpenCL pipe-storage type.",
                    "EnablingCapabilities": [
                        "PipeStorage"
                    ],
                    "MissingBefore": "1.1",
                    "MinWordCount": 2,
                    "Opcode": 322,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpTypeNamedBarrier",
                    "Description": "Declare the named-barrier type.",
                    "EnablingCapabilities": [
                        "NamedBarrier"
                    ],
                    "MissingBefore": "1.1",
                    "MinWordCount": 2,
                    "Opcode": 327,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Constant-Creation Instructions",
            "Instructions": [
                {
                    "Name": "OpConstantTrue",
                    "Description": "Declare a true Boolean-type scalar constant.\nResult Type must be the scalar Boolean type.",
                    "MinWordCount": 3,
                    "Opcode": 41,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpConstantFalse",
                    "Description": "Declare a false Boolean-type scalar constant.\nResult Type must be the scalar Boolean type.",
                    "MinWordCount": 3,
                    "Opcode": 42,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpConstant",
                    "Description": "Declare a new integer-type or floating-point-type scalar constant.\nResult Type must be a scalar integer type or floating-point type.\nValue is the bit pattern for the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 43,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpConstantComposite",
                    "Description": "Declare a new composite constant.\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the Constituents. The ordering must be the same between the top-level types in Result Type and the Constituents.\nConstituents become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the Result Type. The Constituents must all be <id>s of non-specialization constant-instruction declarations or an OpUndef.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 44,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Constituents",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpConstantSampler",
                    "Description": "Declare a new sampler constant.\nResult Type must be OpTypeSampler.\nSampler Addressing Mode is the addressing mode; a literal from Sampler Addressing Mode.\nParam is a 32-bit integer and is one of:\n0: Non Normalized\n1: Normalized\nSampler Filter Mode is the filter mode; a literal from Sampler Filter Mode.",
                    "EnablingCapabilities": [
                        "LiteralSampler"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 45,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Sampler Addressing Mode"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Param"
                        },
                        {
                            "Type": "Sampler Filter Mode"
                        }
                    ]
                },
                {
                    "Name": "OpConstantNull",
                    "Description": "Declare a new null constant value.\nThe null value is type dependent, defined as follows:\n-  Scalar Boolean: false\n-  Scalar integer: 0\n-  Scalar floating point: +0.0 (all bits 0)\n-  All other scalars: Abstract\n-  Composites: Members are set recursively to the null constant according to the null value of their constituent types.\nResult Type must be one of the following types:\n-  Scalar or vector Boolean type\n-  Scalar or vector integer type\n-  Scalar or vector floating-point type\n-  Pointer type\n-  Event type\n-  Device side event type\n-  Reservation id type\n-  Queue type\n-  Composite type",
                    "MinWordCount": 3,
                    "Opcode": 46,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpSpecConstantTrue",
                    "Description": "Declare a Boolean-type scalar specialization constant with a default value of true.\nThis instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.\nResult Type must be the scalar Boolean type.\nSee Specialization.",
                    "MinWordCount": 3,
                    "Opcode": 48,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpSpecConstantFalse",
                    "Description": "Declare a Boolean-type scalar specialization constant with a default value of false.\nThis instruction can be specialized to become either an OpConstantTrue or OpConstantFalse instruction.\nResult Type must be the scalar Boolean type.\nSee Specialization.",
                    "MinWordCount": 3,
                    "Opcode": 49,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpSpecConstant",
                    "Description": "Declare a new integer-type or floating-point-type scalar specialization constant.\nResult Type must be a scalar integer type or floating-point type.\nValue is the bit pattern for the default value of the constant. Types 32 bits wide or smaller take one word. Larger types take multiple words, with low-order words appearing first.\nThis instruction can be specialized to become an OpConstant instruction.\nSee Specialization.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 50,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpSpecConstantComposite",
                    "Description": "Declare a new composite specialization constant.\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the Constituents. The ordering must be the same between the top-level types in Result Type and the Constituents.\nConstituents become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result. The Constituents must appear in the order needed by the definition of the type of the result. The Constituents must be the <id> of other specialization constants, constant declarations, or an OpUndef.\nThis instruction will be specialized to an OpConstantComposite instruction.\nSee Specialization.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 51,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Constituents",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpSpecConstantOp",
                    "Description": "Declare a new specialization constant that results from doing an operation.\nResult Type must be the type required by the Result Type of Opcode.\nOpcode is an unsigned 32-bit integer. It must equal one of the following opcodes.\nOpSConvert, OpUConvert (missing before version 1.4), OpFConvert\nOpSNegate, OpNot\nOpIAdd, OpISub\nOpIMul, OpUDiv, OpSDiv, OpUMod, OpSRem, OpSMod\nOpShiftRightLogical, OpShiftRightArithmetic, OpShiftLeftLogical\nOpBitwiseOr, OpBitwiseXor, OpBitwiseAnd\nOpVectorShuffle, OpCompositeExtract, OpCompositeInsert\nOpLogicalOr, OpLogicalAnd, OpLogicalNot,\nOpLogicalEqual, OpLogicalNotEqual\nOpSelect\nOpIEqual, OpINotEqual\nOpULessThan, OpSLessThan\nOpUGreaterThan, OpSGreaterThan\nOpULessThanEqual, OpSLessThanEqual\nOpUGreaterThanEqual, OpSGreaterThanEqual\nIf the Shader capability was declared, the following opcode is also valid:\nOpQuantizeToF16\nIf the Kernel capability was declared, the following opcodes are also valid:\nOpConvertFToS, OpConvertSToF\nOpConvertFToU, OpConvertUToF\nOpUConvert\nOpConvertPtrToU, OpConvertUToPtr\nOpGenericCastToPtr, OpPtrCastToGeneric\nOpBitcast\nOpFNegate\nOpFAdd, OpFSub\nOpFMul, OpFDiv\nOpFRem, OpFMod\nOpAccessChain, OpInBoundsAccessChain\nOpPtrAccessChain, OpInBoundsPtrAccessChain\nOperands are the operands required by opcode, and satisfy the semantics of opcode. In addition, all Operands must be either:\n- the <id>s of other constant instructions, or\n- OpUndef, when allowed by opcode, or\n- for the AccessChain named opcodes, their Base is allowed to be a global (module scope) OpVariable instruction.\nSee Specialization.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 52,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Opcode"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operands",
                            "Listed": true
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Memory Instructions",
            "Instructions": [
                {
                    "Name": "OpVariable",
                    "Description": "Allocate an object in memory, resulting in a pointer to it, which can be used with OpLoad and OpStore.\nResult Type must be an OpTypePointer. Its Type operand is the type of object in memory.\nStorage Class is the Storage Class of the memory holding the object. It must not be Generic. It must be the same as the Storage Class operand of the Result Type.\nInitializer is optional.  If Initializer is present, it will be the initial value of the variable\u2019s memory content. Initializer must be an <id> from a constant instruction or a global (module scope) OpVariable instruction. Initializer must have the same type as the type pointed to by Result Type.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 59,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Storage Class"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Initializer",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpImageTexelPointer",
                    "Description": "Form a pointer to a texel of an image. Use of such a pointer is limited to atomic operations.\nResult Type must be an OpTypePointer whose Storage Class operand is Image. Its Type operand must be a scalar numerical type or OpTypeVoid.\nImage must have a type of OpTypePointer with Type OpTypeImage. The Sampled Type of the type of Image must be the same as the Type pointed to by Result Type. The Dim operand of Type must not be SubpassData.\nCoordinate and Sample specify which texel and sample within the image to form a pointer to.\nCoordinate must be a scalar or vector of integer type.  It must have the number of components specified below, given the following Arrayed and Dim operands of the type of the OpTypeImage.\nIf Arrayed is 0:\n1D: scalar\n2D: 2 components\n3D: 3 components\nCube: 3 components\nRect: 2 components\nBuffer: scalar\nIf Arrayed is 1:\n1D: 2 components\n2D: 3 components\nCube: 3 components; the face and layer combine into the 3rd component, layer_face, such that face is layer_face % 6 and layer is floor(layer_face / 6)\nSample must be an integer type scalar. It specifies which sample to select at the given coordinate. Behavior is undefined unless it is a valid <id> for the value 0 when the OpTypeImage has MS of 0.",
                    "MinWordCount": 6,
                    "Opcode": 60,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sample"
                        }
                    ]
                },
                {
                    "Name": "OpLoad",
                    "Description": "Load through a pointer.\nResult Type is the type of the loaded object. It must be a type with fixed size; i.e., it must not be, nor include, any OpTypeRuntimeArray types.\nPointer is the pointer to load through.  Its type must be an OpTypePointer whose Type operand is the same as Result Type.\nIf present, any Memory Operands must begin with a memory operand literal. If not present, it is the same as specifying the memory operand None.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 61,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Memory Operands",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpStore",
                    "Description": "Store through a pointer.\nPointer is the pointer to store through.  Its type must be an OpTypePointer whose Type operand is the same as the type of Object.\nObject is the object to store.\nIf present, any Memory Operands must begin with a memory operand literal. If not present, it is the same as specifying the memory operand None.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 62,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Object"
                        },
                        {
                            "Type": "Memory Operands",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpCopyMemory",
                    "Description": "Copy from the memory pointed to by Source to the memory pointed to by Target. Both operands must be non-void pointers and having the same <id> Type operand in their OpTypePointer type declaration.  Matching Storage Class is not required.  The amount of memory copied is the size of the type pointed to. The copied type must have a fixed size; i.e., it must not be, nor include, any OpTypeRuntimeArray types.\nIf present, any Memory Operands must begin with a memory operand literal. If not present, it is the same as specifying the memory operand None. Before version 1.4, at most one memory operands mask can be provided. Starting with version 1.4 two masks can be provided, as described in Memory Operands. If no masks or only one mask is present, it applies to both Source and Target. If two masks are present, the first applies to Target and must not include MakePointerVisible, and the second applies to Source and must not include MakePointerAvailable.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 63,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Target"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Source"
                        },
                        {
                            "Type": "Memory Operands",
                            "Optional": true
                        },
                        {
                            "Type": "Memory Operands",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpCopyMemorySized",
                    "Description": "Copy from the memory pointed to by Source to the memory pointed to by Target.\nSize is the number of bytes to copy. It must have a scalar integer type. If it is a constant instruction, the constant value must not be 0. It is invalid for both the constant\u2019s type to have Signedness of 1 and to have the sign bit set. Otherwise, as a run-time value, Size is treated as unsigned, and if its value is 0, no memory access is made.\nIf present, any Memory Operands must begin with a memory operand literal. If not present, it is the same as specifying the memory operand None. Before version 1.4, at most one memory operands mask can be provided. Starting with version 1.4 two masks can be provided, as described in Memory Operands. If no masks or only one mask is present, it applies to both Source and Target. If two masks are present, the first applies to Target and must not include MakePointerVisible, and the second applies to Source and must not include MakePointerAvailable.",
                    "EnablingCapabilities": [
                        "Addresses"
                    ],
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 64,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Target"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Source"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Size"
                        },
                        {
                            "Type": "Memory Operands",
                            "Optional": true
                        },
                        {
                            "Type": "Memory Operands",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpAccessChain",
                    "Description": "Create a pointer into a composite object that can be used with OpLoad and OpStore.\nResult Type must be an OpTypePointer. Its Type operand must be the type reached by walking the Base\u2019s type hierarchy down to the last provided index in Indexes, and its Storage Class operand must be the same as the Storage Class of Base.\nBase must be a pointer, pointing to the base of a composite object.\nIndexes walk the type hierarchy to the desired depth, potentially down to scalar granularity. The first index in Indexes selects the top-level member/element/component/element of the base composite. All composite constituents use zero-based numbering, as described by their OpType\u2026 instruction. The second index applies similarly to that result, and so on. Once any non-composite type is reached, there must be no remaining (unused) indexes.\nEach index in Indexes\n- must have a scalar integer type\n- is treated as signed\n- if indexing into a structure, must be an OpConstant whose value is in bounds for selecting a member\n- if indexing into a vector, array, or matrix,   with the result type being a logical pointer type, causes undefined behavior if not in bounds.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 65,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Indexes",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpInBoundsAccessChain",
                    "Description": "Has the same semantics as OpAccessChain, with the addition that the resulting pointer is known to point within the base object.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 66,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Indexes",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpPtrAccessChain",
                    "Description": "Has the same semantics as OpAccessChain, with the addition of the Element operand.\nElement is used to do an initial dereference of Base: Base is treated as the address of an element in an array, and a new element address is computed from Base and Element to become the OpAccessChain Base to dereference as per OpAccessChain. This computed Base has the same type as the originating Base.\nTo compute the new element address, Element is treated as a signed count of elements E, relative to the original Base element B, and the address of element B + E is computed using enough precision to avoid overflow and underflow. For objects in the Uniform, StorageBuffer, or PushConstant storage classes, the element\u2019s address or location is calculated using a stride, which will be the Base-type\u2019s Array Stride if the Base type is decorated with ArrayStride. For all other objects, the implementation calculates the element\u2019s address or location.\nWith one exception, undefined behavior results when B + E is not an element in the same array (same innermost array, if array types are nested) as B. The exception being when B + E = L, where L is the length of the array: the address computation for element L is done with the same stride as any other B + E computation that stays within the array.\nNote: If Base is typed to be a pointer to an array and the desired operation is to select an element of that array, OpAccessChain should be directly used, as its first Index selects the array element.",
                    "EnablingCapabilities": [
                        "Addresses",
                        "VariablePointers",
                        "VariablePointersStorageBuffer",
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 67,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Element"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Indexes",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpArrayLength",
                    "Description": "Length of a run-time array.\nResult Type must be an OpTypeInt with 32-bit Width and 0 Signedness.\nStructure must be a logical pointer to an OpTypeStruct whose last member is a run-time array.\nArray member is an unsigned 32-bit integer index of the last member of the structure that Structure points to. That member\u2019s type must be from OpTypeRuntimeArray.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 68,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Structure"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Array member"
                        }
                    ]
                },
                {
                    "Name": "OpGenericPtrMemSemantics",
                    "Description": "Result is a valid Memory Semantics which includes mask bits set for the Storage Class for the specific (non-Generic) Storage Class of Pointer.\nPointer must point to Generic Storage Class.\nResult Type must be an OpTypeInt with 32-bit Width and 0 Signedness.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 69,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        }
                    ]
                },
                {
                    "Name": "OpInBoundsPtrAccessChain",
                    "Description": "Has the same semantics as OpPtrAccessChain, with the addition that the resulting pointer is known to point within the base object.",
                    "EnablingCapabilities": [
                        "Addresses"
                    ],
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 70,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Element"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Indexes",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpPtrEqual",
                    "Description": "Result is true if Operand 1 and Operand 2 have the same value. Result is false if Operand 1 and Operand 2 have different values.\nResult Type must be a Boolean type scalar.\nThe types of Operand 1 and Operand 2 must be OpTypePointer of the same type.",
                    "MissingBefore": "1.4",
                    "MinWordCount": 5,
                    "Opcode": 401,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpPtrNotEqual",
                    "Description": "Result is true if Operand 1 and Operand 2 have different values. Result is false if Operand 1 and Operand 2 have the same value.\nResult Type must be a Boolean type scalar.\nThe types of Operand 1 and Operand 2 must be OpTypePointer of the same type.",
                    "MissingBefore": "1.4",
                    "MinWordCount": 5,
                    "Opcode": 402,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpPtrDiff",
                    "Description": "Element-number subtraction: The number of elements to add to Operand 2 to get to Operand 1.\nResult Type must be an integer type scalar. It is computed as a signed value, as negative differences are allowed, independently of the signed bit in the type. The result equals the low-order N bits of the correct result R, where R is computed with enough precision to avoid overflow and underflow and Result Type has a bitwidth of N bits.\nThe units of Result Type are a count of elements. I.e., the same value you would use as the Element operand to OpPtrAccessChain.\nThe types of Operand 1 and Operand 2 must be OpTypePointer of exactly the same type, and point to a type that can be aggregated into an array. For an array of length L, Operand 1 and Operand 2 can point to any element in the range [0, L], where element L is outside the array but has a representative address computed with the same stride as elements in the array. Additionally, Operand 1 must be a valid Base operand of OpPtrAccessChain. Behavior is undefined if Operand 1 and Operand 2 are not pointers to element numbers in [0, L] in the same array.",
                    "EnablingCapabilities": [
                        "Addresses",
                        "VariablePointers",
                        "VariablePointersStorageBuffer"
                    ],
                    "MissingBefore": "1.4",
                    "MinWordCount": 5,
                    "Opcode": 403,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Function Instructions",
            "Instructions": [
                {
                    "Name": "OpFunction",
                    "Description": "Add a function.  This instruction must be immediately followed by one OpFunctionParameter instruction per each formal parameter of this function. This function\u2019s body or declaration terminates with the next OpFunctionEnd instruction.\nResult Type must be the same as the Return Type declared in Function Type.\nFunction Type is the result of an OpTypeFunction, which declares the types of the return value and parameters of the function.",
                    "MinWordCount": 5,
                    "Opcode": 54,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Function Control"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Function Type"
                        }
                    ]
                },
                {
                    "Name": "OpFunctionParameter",
                    "Description": "Declare a formal parameter of the current function.\nResult Type is the type of the parameter.\nThis instruction must immediately follow an OpFunction or OpFunctionParameter instruction. The order of contiguous OpFunctionParameter instructions is the same order arguments are listed in an OpFunctionCall instruction to this function. It is also the same order in which Parameter Type operands are listed in the OpTypeFunction of the Function Type operand for this function\u2019s OpFunction instruction.",
                    "MinWordCount": 3,
                    "Opcode": 55,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpFunctionEnd",
                    "Description": "Last instruction of a function.",
                    "MinWordCount": 1,
                    "Opcode": 56
                },
                {
                    "Name": "OpFunctionCall",
                    "Description": "Call a function.\nResult Type is the type of the return value of the function. It must be the same as the Return Type operand of the Function Type operand of the Function operand.\nFunction is an OpFunction instruction.  This could be a forward reference.\nArgument N is the object to copy to parameter N of Function.\nNote: A forward call is possible because there is no missing type information: Result Type must match the Return Type of the function, and the calling argument types must match the formal parameter types.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 57,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Function"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Argument",
                            "Listed": true
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Image Instructions",
            "Instructions": [
                {
                    "Name": "OpSampledImage",
                    "Description": "Create a sampled image, containing both a sampler and an image.\nResult Type must be the OpTypeSampledImage type whose Image Type operand is the type of Image.\nImage is an object whose type is an OpTypeImage, whose Sampled operand is 0 or 1, and whose Dim operand is not SubpassData.\nSampler must be an object whose type is OpTypeSampler.",
                    "MinWordCount": 5,
                    "Opcode": 86,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampler"
                        }
                    ]
                },
                {
                    "Name": "OpImageSampleImplicitLod",
                    "Description": "Sample an image with an implicit level of detail.\nResult Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\nSampled Image must be an object whose type is OpTypeSampledImage. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nImage Operands encodes what operands follow, as per Image Operands.\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 87,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSampleExplicitLod",
                    "Description": "Sample an image using an explicit level of detail.\nResult Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\nSampled Image must be an object whose type is OpTypeSampledImage. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image. Unless the Kernel capability is being used, it must be floating point. It may be a vector larger than needed, but all unused components appear after all used components.\nImage Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.",
                    "MinWordCount": 7,
                    "VariableWordCount": true,
                    "Opcode": 88,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands"
                        },
                        {
                            "Type": "<id>"
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSampleDrefImplicitLod",
                    "Description": "Sample an image doing depth-comparison with an implicit level of detail.\nResult Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\nSampled Image must be an object whose type is OpTypeSampledImage. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nDref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar.\nImage Operands encodes what operands follow, as per Image Operands.\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 89,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSampleDrefExplicitLod",
                    "Description": "Sample an image doing depth-comparison using an explicit level of detail.\nResult Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\nSampled Image must be an object whose type is OpTypeSampledImage. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nDref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar.\nImage Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 8,
                    "VariableWordCount": true,
                    "Opcode": 90,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands"
                        },
                        {
                            "Type": "<id>"
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSampleProjImplicitLod",
                    "Description": "Sample an image with with a project coordinate and an implicit level of detail.\nResult Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nImage Operands encodes what operands follow, as per Image Operands.\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 91,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSampleProjExplicitLod",
                    "Description": "Sample an image with a project coordinate using an explicit level of detail.\nResult Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nImage Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 7,
                    "VariableWordCount": true,
                    "Opcode": 92,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands"
                        },
                        {
                            "Type": "<id>"
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSampleProjDrefImplicitLod",
                    "Description": "Sample an image with a project coordinate, doing depth-comparison, with an implicit level of detail.\nResult Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nDref /q is the depth-comparison reference value. Dref must be a 32-bit floating-point type scalar.\nImage Operands encodes what operands follow, as per Image Operands.\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 93,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSampleProjDrefExplicitLod",
                    "Description": "Sample an image with a project coordinate, doing depth-comparison, using an explicit level of detail.\nResult Type must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\nSampled Image must be an object whose type is OpTypeSampledImage. The Dim operand of the underlying OpTypeImage must be 1D, 2D, 3D, or Rect,  and the Arrayed and MS operands must be 0.\nCoordinate is a floating-point vector containing (u [, v] [, w], q), as needed by the definition of Sampled Image, with the q component consumed for the projective division. That is, the actual sample coordinate is (u/q [, v/q] [, w/q]), as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nDref /q is the depth-comparison reference value. Dref must be a 32-bit floating-point type scalar.\nImage Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 8,
                    "VariableWordCount": true,
                    "Opcode": 94,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands"
                        },
                        {
                            "Type": "<id>"
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageFetch",
                    "Description": "Fetch a single texel from an image whose Sampled operand is 1.\nResult Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\nImage must be an object whose type is OpTypeImage. Its Dim operand must not be Cube, and its Sampled operand must be 1.\nCoordinate is an integer scalar or vector containing (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image.\nImage Operands encodes what operands follow, as per Image Operands.",
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 95,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageGather",
                    "Description": "Gathers the requested component from four texels.\nResult Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image.\nComponent is the component number gathered from all four texels. It must be a 32-bit integer type scalar.  Behavior is undefined if its value is not 0, 1, 2 or 3.\nImage Operands encodes what operands follow, as per Image Operands.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 96,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Component"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageDrefGather",
                    "Description": "Gathers the requested depth-comparison from four texels.\nResult Type must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image.\nDref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar.\nImage Operands encodes what operands follow, as per Image Operands.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 97,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageRead",
                    "Description": "Read a texel from an image without a sampler.\nResult Type must be a scalar or vector of floating-point type or integer type.  It must be a scalar or vector with component type the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).\nImage must be an object whose type is OpTypeImage with a Sampled operand of 0 or 2. If the Arrayed operand is 1, then additional capabilities may be required;  e.g., ImageCubeArray, or ImageMSArray.\nCoordinate is an integer scalar or vector containing non-normalized texel coordinates (u[, v] \u2026 [, array layer]) as needed by the definition of Image. See the client API specification for handling of coordinates outside the image.\nIf the Image Dim operand is SubpassData, Coordinate is relative to the current fragment location. See the client API specification for more detail on how these coordinates are applied.\nIf the Image Dim operand is not SubpassData, the Image Format must not be Unknown, unless the StorageImageReadWithoutFormat Capability was declared.\nImage Operands encodes what operands follow, as per Image Operands.",
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 98,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageWrite",
                    "Description": "Write a texel to an image without a sampler.\nImage must be an object whose type is OpTypeImage with a Sampled operand of 0 or 2. If the Arrayed operand is 1, then additional capabilities may be required;  e.g., ImageCubeArray, or ImageMSArray. Its Dim operand must not be SubpassData.\nCoordinate is an integer scalar or vector containing non-normalized texel coordinates (u[, v] \u2026 [, array layer]) as needed by the definition of Image. See the client API specification for handling of coordinates outside the image.\nTexel is the data to write. It must be a scalar or vector with component type the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).\nThe Image Format must not be Unknown, unless the StorageImageWriteWithoutFormat Capability was declared.\nImage Operands encodes what operands follow, as per Image Operands.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 99,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Texel"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImage",
                    "Description": "Extract the image from a sampled image.\nResult Type must be OpTypeImage.\nSampled Image must have type OpTypeSampledImage whose Image Type is the same as Result Type.",
                    "MinWordCount": 4,
                    "Opcode": 100,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        }
                    ]
                },
                {
                    "Name": "OpImageQueryFormat",
                    "Description": "Query the image format of an image created with an Unknown Image Format.\nResult Type must be a scalar integer type. The resulting value is an enumerant from Image Channel Data Type.\nImage must be an object whose type is OpTypeImage.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 101,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        }
                    ]
                },
                {
                    "Name": "OpImageQueryOrder",
                    "Description": "Query the channel order of an image created with an Unknown Image Format.\nResult Type must be a scalar integer type. The resulting value is an enumerant from Image Channel Order.\nImage must be an object whose type is OpTypeImage.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 102,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        }
                    ]
                },
                {
                    "Name": "OpImageQuerySizeLod",
                    "Description": "Query the dimensions of Image for mipmap level for Level of Detail.\nResult Type must be an integer type scalar or vector.  The number of components must be\n1 for the 1D dimensionality,\n2 for the 2D and Cube dimensionalities,\n3 for the 3D dimensionality,\nplus 1 more if the image type is arrayed. This vector is filled in with (width [, height] [, depth] [, elements]) where elements is the number of layers in an image array, or the number of cubes in a cube-map array.\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube, and its MS must be 0. See OpImageQuerySize for querying image types without level of detail. This operation is allowed on an image decorated as NonReadable. See the client API specification for additional image type restrictions.\nLevel of Detail is used to compute which mipmap level to query, as specified by the client API.",
                    "EnablingCapabilities": [
                        "Kernel",
                        "ImageQuery"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 103,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Level of Detail"
                        }
                    ]
                },
                {
                    "Name": "OpImageQuerySize",
                    "Description": "Query the dimensions of Image, with no level of detail.\nResult Type must be an integer type scalar or vector.  The number of components must be:\n1 for the 1D and Buffer dimensionalities,\n2 for the 2D, Cube, and Rect dimensionalities,\n3 for the 3D dimensionality,\nplus 1 more if the image type is arrayed. This vector is filled in with (width [, height] [, elements]) where elements is the number of layers in an image array or the number of cubes in a cube-map array.\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of those listed under Result Type, above. Additionally, if its Dim is 1D, 2D, 3D, or Cube, it must also have either an MS of 1 or a Sampled of 0 or 2. There is no implicit level-of-detail consumed by this instruction. See OpImageQuerySizeLod for querying images having level of detail. This operation is allowed on an image decorated as NonReadable. See the client API specification for additional image type restrictions.",
                    "EnablingCapabilities": [
                        "Kernel",
                        "ImageQuery"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 104,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        }
                    ]
                },
                {
                    "Name": "OpImageQueryLod",
                    "Description": "Query the mipmap level and the level of detail for a hypothetical sampling of Image at Coordinate using an implicit level of detail.\nResult Type must be a two-component floating-point type vector.\nThe first component of the result contains the mipmap array layer.\nThe second component of the result contains the implicit level of detail relative to the base level.\nSampled Image must be an object whose type is OpTypeSampledImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube.\nCoordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] \u2026 ) as needed by the definition of Sampled Image, not including any array layer index. Unless the Kernel capability is being used, it must be floating point.\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
                    "EnablingCapabilities": [
                        "ImageQuery"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 105,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        }
                    ]
                },
                {
                    "Name": "OpImageQueryLevels",
                    "Description": "Query the number of mipmap levels accessible through Image.\nResult Type must be a scalar integer type. The result is the number of mipmap levels,as specified by the client API.\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of 1D, 2D, 3D, or Cube. See the client API specification for additional image type restrictions.",
                    "EnablingCapabilities": [
                        "Kernel",
                        "ImageQuery"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 106,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        }
                    ]
                },
                {
                    "Name": "OpImageQuerySamples",
                    "Description": "Query the number of samples available per texel fetch in a multisample image.\nResult Type must be a scalar integer type. The result is the number of samples.\nImage must be an object whose type is OpTypeImage. Its Dim operand must be one of 2D and MS of 1.",
                    "EnablingCapabilities": [
                        "Kernel",
                        "ImageQuery"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 107,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseSampleImplicitLod",
                    "Description": "Sample a sparse image with an implicit level of detail.\nResult Type must be an OpTypeStruct with two members. The first member\u2019s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\nSampled Image must be an object whose type is OpTypeSampledImage. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nImage Operands encodes what operands follow, as per Image Operands.\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 305,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseSampleExplicitLod",
                    "Description": "Sample a sparse image using an explicit level of detail.\nResult Type must be an OpTypeStruct with two members. The first member\u2019s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\nSampled Image must be an object whose type is OpTypeSampledImage. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type or integer type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image. Unless the Kernel capability is being used, it must be floating point. It may be a vector larger than needed, but all unused components appear after all used components.\nImage Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "MinWordCount": 7,
                    "VariableWordCount": true,
                    "Opcode": 306,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands"
                        },
                        {
                            "Type": "<id>"
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseSampleDrefImplicitLod",
                    "Description": "Sample a sparse image doing depth-comparison with an implicit level of detail.\nResult Type must be an OpTypeStruct with two members. The first member\u2019s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\nSampled Image must be an object whose type is OpTypeSampledImage. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nDref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar.\nImage Operands encodes what operands follow, as per Image Operands.\nThis instruction is only valid in the Fragment Execution Model. In addition, it consumes an implicit derivative that can be affected by code motion.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 307,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseSampleDrefExplicitLod",
                    "Description": "Sample a sparse image doing depth-comparison using an explicit level of detail.\nResult Type must be an OpTypeStruct with two members. The first member\u2019s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar of integer type or floating-point type.  It must be the same as Sampled Type of the underlying OpTypeImage.\nSampled Image must be an object whose type is OpTypeSampledImage. The MS operand of the underlying OpTypeImage must be 0.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image. It may be a vector larger than needed, but all unused components appear after all used components.\nDref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar.\nImage Operands encodes what operands follow, as per Image Operands. Either Lod or Grad image operands must be present.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "MinWordCount": 8,
                    "VariableWordCount": true,
                    "Opcode": 308,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands"
                        },
                        {
                            "Type": "<id>"
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseSampleProjImplicitLod",
                    "Description": "Sample a sparse image with a projective coordinate and an implicit level of detail.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 309,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseSampleProjExplicitLod",
                    "Description": "Sample a sparse image with a projective coordinate using an explicit level of detail.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "Reserved": true,
                    "MinWordCount": 7,
                    "VariableWordCount": true,
                    "Opcode": 310,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands"
                        },
                        {
                            "Type": "<id>"
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseSampleProjDrefImplicitLod",
                    "Description": "Sample a sparse image with a projective coordinate, doing depth-comparison, with an implicit level of detail.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 311,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseSampleProjDrefExplicitLod",
                    "Description": "Sample a sparse image with a projective coordinate, doing depth-comparison, using an explicit level of detail.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "Reserved": true,
                    "MinWordCount": 8,
                    "VariableWordCount": true,
                    "Opcode": 312,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands"
                        },
                        {
                            "Type": "<id>"
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseFetch",
                    "Description": "Fetch a single texel from a sampled sparse image.\nResult Type must be an OpTypeStruct with two members. The first member\u2019s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid).\nImage must be an object whose type is OpTypeImage. Its Dim operand must not be Cube.\nCoordinate is an integer scalar or vector containing (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image.\nImage Operands encodes what operands follow, as per Image Operands.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 313,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseGather",
                    "Description": "Gathers the requested component from four texels of a sparse image.\nResult Type must be an OpTypeStruct with two members. The first member\u2019s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image.\nComponent is the component number gathered from all four texels. It must be a 32-bit integer type scalar.  Behavior is undefined if its value is not 0, 1, 2 or 3.\nImage Operands encodes what operands follow, as per Image Operands.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 314,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Component"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseDrefGather",
                    "Description": "Gathers the requested depth-comparison from four texels of a sparse image.\nResult Type must be an OpTypeStruct with two members. The first member\u2019s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a vector of four components of floating-point type or integer type.  Its components must be the same as Sampled Type of the underlying OpTypeImage (unless that underlying Sampled Type is OpTypeVoid). It has one component per gathered texel.\nSampled Image must be an object whose type is OpTypeSampledImage. Its OpTypeImage must have a Dim of 2D, Cube, or Rect.\nCoordinate  must be a scalar or vector of floating-point type.  It contains (u[, v] \u2026 [, array layer]) as needed by the definition of Sampled Image.\nDref is the depth-comparison reference value. It must be a 32-bit floating-point type scalar.\nImage Operands encodes what operands follow, as per Image Operands.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 315,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Dref"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseTexelsResident",
                    "Description": "Translates a Resident Code into a Boolean. Result is false if any of the texels were in uncommitted texture memory, and true otherwise.\nResult Type must be a Boolean type scalar.\nResident Code is a value from an OpImageSparse\u2026 instruction that results in a resident code.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 316,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Resident Code"
                        }
                    ]
                },
                {
                    "Name": "OpImageSparseRead",
                    "Description": "Read a texel from a sparse image without a sampler.\nResult Type must be an OpTypeStruct with two members. The first member\u2019s type must be an integer type scalar.  It holds a Residency Code that can be passed to OpImageSparseTexelsResident. The second member  must be a scalar or vector of floating-point type or integer type.  It must be a scalar or vector with component type the same as Sampled Type of the OpTypeImage (unless that Sampled Type is OpTypeVoid).\nImage must be an object whose type is OpTypeImage with a Sampled operand of 2.\nCoordinate is an integer scalar or vector containing non-normalized texel coordinates (u[, v] \u2026 [, array layer]) as needed by the definition of Image. See the client API specification for handling of coordinates outside the image.\nThe Image Dim operand must not be SubpassData. The Image Format must not be Unknown unless the StorageImageReadWithoutFormat Capability was declared.\nImage Operands encodes what operands follow, as per Image Operands.",
                    "EnablingCapabilities": [
                        "SparseResidency"
                    ],
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 320,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpImageSampleFootprintNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "ImageFootprintNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 7,
                    "VariableWordCount": true,
                    "Opcode": 5283,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Sampled Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Granularity"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coarse"
                        },
                        {
                            "Type": "Image Operands",
                            "Optional": true
                        },
                        {
                            "Type": "<id>",
                            "Listed": true
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Conversion Instructions",
            "Instructions": [
                {
                    "Name": "OpConvertFToU",
                    "Description": "Convert value numerically from floating point to unsigned integer, with round toward 0.0.\nResult Type must be a scalar or vector of integer type, whose Signedness operand is 0.  Behavior is undefined if Result Type is not wide enough to hold the converted value.\nFloat Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 109,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Float Value"
                        }
                    ]
                },
                {
                    "Name": "OpConvertFToS",
                    "Description": "Convert value numerically from floating point to signed integer, with round toward 0.0.\nResult Type must be a scalar or vector of integer type.  Behavior is undefined if Result Type is not wide enough to hold the converted value.\nFloat Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 110,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Float Value"
                        }
                    ]
                },
                {
                    "Name": "OpConvertSToF",
                    "Description": "Convert value numerically from signed integer to floating point.\nResult Type must be a scalar or vector of floating-point type.\nSigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 111,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Signed Value"
                        }
                    ]
                },
                {
                    "Name": "OpConvertUToF",
                    "Description": "Convert value numerically from unsigned integer to floating point.\nResult Type must be a scalar or vector of floating-point type.\nUnsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 112,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Unsigned Value"
                        }
                    ]
                },
                {
                    "Name": "OpUConvert",
                    "Description": "Convert unsigned width. This is either a truncate or a zero extend.\nResult Type must be a scalar or vector of integer type, whose Signedness operand is 0.\nUnsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must not equal the component width in Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 113,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Unsigned Value"
                        }
                    ]
                },
                {
                    "Name": "OpSConvert",
                    "Description": "Convert signed width.  This is either a truncate or a sign extend.\nResult Type must be a scalar or vector of integer type.\nSigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must not equal the component width in Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 114,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Signed Value"
                        }
                    ]
                },
                {
                    "Name": "OpFConvert",
                    "Description": "Convert value numerically from one floating-point width to another width.\nResult Type must be a scalar or vector of floating-point type.\nFloat Value must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.  The component width must not equal the component width in Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 115,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Float Value"
                        }
                    ]
                },
                {
                    "Name": "OpQuantizeToF16",
                    "Description": "Quantize a floating-point value to what is expressible by a 16-bit floating-point value.\nResult Type must be a scalar or vector of floating-point type. The component width must be 32 bits.\nValue is the value to quantize. The type of Value must be the same as Result Type.\nIf Value is an infinity, the result is the same infinity. If Value is a NaN, the result is a NaN, but not necessarily the same NaN. If Value is positive with a magnitude too large to represent as a 16-bit floating-point value, the result is positive infinity. If Value is negative with a magnitude too large to represent as a 16-bit floating-point value, the result is negative infinity. If the magnitude of Value is too small to represent as a normalized 16-bit floating-point value, the result may be either +0 or -0.\nThe RelaxedPrecision Decoration has no effect on this instruction.\nResults are computed per component.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 116,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpConvertPtrToU",
                    "Description": "Bit pattern-preserving conversion of a pointer to an unsigned scalar integer of possibly different bit width.\nResult Type must be a scalar of integer type, whose Signedness operand is 0.\nPointer must be a physical pointer type. If the bit width of Pointer is smaller than that of Result Type, the conversion zero extends Pointer. If the bit width of Pointer is larger than that of Result Type, the conversion truncates Pointer. For same bit width Pointer and Result Type, this is the same as OpBitcast.",
                    "EnablingCapabilities": [
                        "Addresses",
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 117,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        }
                    ]
                },
                {
                    "Name": "OpSatConvertSToU",
                    "Description": "Convert a signed integer to unsigned integer. Converted values outside the representable range of Result Type are clamped to the nearest representable value of Result Type.\nResult Type must be a scalar or vector of integer type.\nSigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 118,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Signed Value"
                        }
                    ]
                },
                {
                    "Name": "OpSatConvertUToS",
                    "Description": "Convert an unsigned integer to signed integer.  Converted values outside the representable range of Result Type are clamped to the nearest representable value of Result Type.\nResult Type must be a scalar or vector of integer type.\nUnsigned Value must be a scalar or vector of integer type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 119,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Unsigned Value"
                        }
                    ]
                },
                {
                    "Name": "OpConvertUToPtr",
                    "Description": "Bit pattern-preserving conversion of an unsigned scalar integer to a pointer.\nResult Type must be a physical pointer type.\nInteger Value  must be a scalar of integer type, whose Signedness operand is 0.  If the bit width of Integer Value is smaller than that of Result Type, the conversion zero extends Integer Value. If the bit width of Integer Value is larger than that of Result Type, the conversion truncates Integer Value. For same-width Integer Value and Result Type, this is the same as OpBitcast.",
                    "EnablingCapabilities": [
                        "Addresses",
                        "PhysicalStorageBufferAddresses"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 120,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Integer Value"
                        }
                    ]
                },
                {
                    "Name": "OpPtrCastToGeneric",
                    "Description": "Convert a pointer\u2019s Storage Class to Generic.\nResult Type must be an OpTypePointer. Its Storage Class must be Generic.\nPointer must point to the Workgroup, CrossWorkgroup, or Function Storage Class.\nResult Type and Pointer must point to the same type.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 121,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        }
                    ]
                },
                {
                    "Name": "OpGenericCastToPtr",
                    "Description": "Convert a pointer\u2019s Storage Class to a non-Generic class.\nResult Type must be an OpTypePointer. Its Storage Class must be Workgroup, CrossWorkgroup, or Function.\nPointer must point to the Generic Storage Class.\nResult Type and Pointer must point to the same type.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 122,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        }
                    ]
                },
                {
                    "Name": "OpGenericCastToPtrExplicit",
                    "Description": "Attempts to explicitly convert Pointer to Storage storage-class pointer value.\nResult Type must be an OpTypePointer. Its Storage Class must be Storage.\nPointer must have a type of OpTypePointer whose Type is the same as the Type of Result Type.Pointer must point to the Generic Storage Class. If the cast fails, the instruction result is an OpConstantNull pointer in the Storage Storage Class.\nStorage must be one of the following literal values from Storage Class: Workgroup, CrossWorkgroup, or Function.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 123,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Storage Class",
                            "Description": "Storage"
                        }
                    ]
                },
                {
                    "Name": "OpBitcast",
                    "Description": "Bit pattern-preserving type conversion.\nResult Type must be an OpTypePointer, or a scalar or vector of numerical-type.\nOperand must have a type of OpTypePointer, or a scalar or vector of numerical-type. It must be a different type than Result Type.\nBefore version 1.5: If either Result Type or Operand is a pointer,  the other must be a pointer or an integer scalar.\nStarting with version 1.5: If either Result Type or Operand is a pointer,  the other must be a pointer, an integer scalar, or an integer vector.\nIf Result Type has the same number of components as Operand, they must also have the same component width, and results are computed per component.\nIf Result Type has a different number of components than Operand, the total number of bits in Result Type must equal the total number of bits in Operand. Let L be the type, either Result Type or Operand\u2019s type, that has the larger number of components. Let S be the other type, with the smaller number of components. The number of components in L must be an integer multiple of the number of components in S. The first component (that is, the only or lowest-numbered component) of S maps to the first components of L, and so on,  up to the last component of S mapping to the last components of L. Within this mapping, any single component of S (mapping to multiple components of L) maps its lower-ordered bits to the lower-numbered components of L.",
                    "MinWordCount": 4,
                    "Opcode": 124,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Composite Instructions",
            "Instructions": [
                {
                    "Name": "OpVectorExtractDynamic",
                    "Description": "Extract a single, dynamically selected, component of a vector.\nResult Type must be a scalar type.\nVector must have a type OpTypeVector whose Component Type is Result Type.\nIndex must be a scalar integer. It is interpreted as a 0-based index of which component of Vector to extract.\nBehavior is undefined if Index\u2019s value is less than zero or greater than or equal to the number of components in Vector.",
                    "MinWordCount": 5,
                    "Opcode": 77,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Index"
                        }
                    ]
                },
                {
                    "Name": "OpVectorInsertDynamic",
                    "Description": "Make a copy of a vector, with a single, variably selected, component modified.\nResult Type must be an OpTypeVector.\nVector must have the same type as Result Type and is the vector that the non-written components are copied from.\nComponent is the value supplied for the component selected by Index. It must have the same type as the type of components in Result Type.\nIndex must be a scalar integer. It is interpreted as a 0-based index of which component to modify.\nBehavior is undefined if Index\u2019s value is less than zero or greater than or equal to the number of components in Vector.",
                    "MinWordCount": 6,
                    "Opcode": 78,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Component"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Index"
                        }
                    ]
                },
                {
                    "Name": "OpVectorShuffle",
                    "Description": "Select arbitrary components from two vectors to make a new vector.\nResult Type must be an OpTypeVector. The number of components in Result Type must be the same as the number of Component operands.\nVector 1 and Vector 2 must both have vector types, with the same Component Type as Result Type. They do not have to have the same number of components as Result Type or with each other. They are logically concatenated, forming a single vector with Vector 1\u2019s components appearing before Vector 2\u2019s. The components of this logical vector are logically numbered with a single consecutive set of numbers from 0 to N - 1, where N is the total number of components.\nComponents are these logical numbers (see above), selecting which of the logically numbered components form the result. Each component is an unsigned 32-bit integer.  They can select the components in any order and can repeat components. The first component of the result is selected by the first Component operand,  the second component of the result is selected by the second Component operand, etc. A Component literal may also be FFFFFFFF, which means the corresponding result component has no source and is undefined. All Component literals must either be FFFFFFFF or in [0, N - 1] (inclusive).\nNote: A vector \u201cswizzle\u201d can be done by using the vector for both Vector operands, or using an OpUndef for one of the Vector operands.",
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 79,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector 2"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Components",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpCompositeConstruct",
                    "Description": "Construct a new composite object from a set of constituent objects.\nResult Type must be a composite type, whose top-level members/elements/components/columns have the same type as the types of the operands, with one exception. The exception is that for constructing a vector, the operands may also be vectors with the same component type as the Result Type component type. If constructing a vector, the total number of components in all the operands must equal the number of components in Result Type.\nConstituents become members of a structure, or elements of an array, or components of a vector, or columns of a matrix. There must be exactly one Constituent for each top-level member/element/component/column of the result, with one exception. The exception is that for constructing a vector, a contiguous subset of the scalars consumed can be represented by a vector operand instead. The Constituents must appear in the order needed by the definition of the type of the result. If constructing a vector, there must be at least two Constituent operands.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 80,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Constituents",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpCompositeExtract",
                    "Description": "Extract a part of a composite object.\nResult Type must be the type of object selected by the last provided index.  The instruction result is the extracted object.\nComposite is the composite to extract from.\nIndexes walk the type hierarchy, potentially down to component granularity, to select the part to extract. All indexes must be in bounds.  All composite constituents use zero-based numbering, as described by their OpType\u2026 instruction. Each index is an unsigned 32-bit integer.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 81,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Composite"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Indexes",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpCompositeInsert",
                    "Description": "Make a copy of a composite object, while modifying one part of it.\nResult Type must be the same type as Composite.\nObject is the object to use as the modified part.\nComposite is the composite to copy all but the modified part from.\nIndexes walk the type hierarchy of Composite to the desired depth, potentially down to component granularity, to select the part to modify. All indexes must be in bounds. All composite constituents use zero-based numbering, as described by their OpType\u2026 instruction. The type of the part selected to modify must match the type of Object. Each index is an unsigned 32-bit integer.",
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 82,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Object"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Composite"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Indexes",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpCopyObject",
                    "Description": "Make a copy of Operand. There are no pointer dereferences involved.\nResult Type must equal Operand type.  There are no other restrictions on the types.",
                    "MinWordCount": 4,
                    "Opcode": 83,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand"
                        }
                    ]
                },
                {
                    "Name": "OpTranspose",
                    "Description": "Transpose a matrix.\nResult Type must be an OpTypeMatrix.\nMatrix must be an object of type OpTypeMatrix. The number of columns and the column size of Matrix must be the reverse of those in Result Type. The types of the scalar components in Matrix and Result Type must be the same.\nMatrix must have of type of OpTypeMatrix.",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 84,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Matrix"
                        }
                    ]
                },
                {
                    "Name": "OpCopyLogical",
                    "Description": "Make a logical copy of Operand. There are no pointer dereferences involved.\nResult Type must not equal the type of Operand (see OpCopyObject), but Result Type must logically match the Operand type.\nLogically match is recursively defined by these three rules:\n1. They must be either both be OpTypeArray or both be OpTypeStruct\n2. If they are OpTypeArray:\n- they must have the same Length operand, and\n- their Element Type operands must be either the same or must logically match.\n3. If they are OpTypeStruct:\n- they must have the same number of Member type, and\n- Member N type for the same N in the two types must be either the same or must logically match.",
                    "MissingBefore": "1.4",
                    "MinWordCount": 4,
                    "Opcode": 400,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Arithmetic Instructions",
            "Instructions": [
                {
                    "Name": "OpSNegate",
                    "Description": "Signed-integer subtract of Operand from zero.\nResult Type must be a scalar or vector of integer type.\nOperand\u2019s type  must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must equal the component width in Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 126,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand"
                        }
                    ]
                },
                {
                    "Name": "OpFNegate",
                    "Description": "Inverts the sign bit of Operand. (Note, however, that OpFNegate is still considered a floating-point instruction, and so is subject to the general floating-point rules regarding, for example, subnormals and NaN propagation).\nResult Type must be a scalar or vector of floating-point type.\nThe type of Operand must be the same as Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 127,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand"
                        }
                    ]
                },
                {
                    "Name": "OpIAdd",
                    "Description": "Integer addition of Operand 1 and Operand 2.\nResult Type must be a scalar or vector of integer type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.\nThe resulting value equals the low-order N bits of the correct result R, where N is the component width and R is computed with enough precision to avoid overflow and underflow.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 128,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFAdd",
                    "Description": "Floating-point addition of Operand 1 and Operand 2.\nResult Type must be a scalar or vector of floating-point type.\nThe types of Operand 1 and Operand 2 both must be the same as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 129,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpISub",
                    "Description": "Integer subtraction of Operand 2 from Operand 1.\nResult Type must be a scalar or vector of integer type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.\nThe resulting value equals the low-order N bits of the correct result R, where N is the component width and R is computed with enough precision to avoid overflow and underflow.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 130,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFSub",
                    "Description": "Floating-point subtraction of Operand 2 from Operand 1.\nResult Type must be a scalar or vector of floating-point type.\nThe types of Operand 1 and Operand 2 both must be the same as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 131,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpIMul",
                    "Description": "Integer multiplication of Operand 1 and Operand 2.\nResult Type must be a scalar or vector of integer type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.\nThe resulting value equals the low-order N bits of the correct result R, where N is the component width and R is computed with enough precision to avoid overflow and underflow.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 132,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFMul",
                    "Description": "Floating-point multiplication of Operand 1 and Operand 2.\nResult Type must be a scalar or vector of floating-point type.\nThe types of Operand 1 and Operand 2 both must be the same as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 133,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUDiv",
                    "Description": "Unsigned-integer division of Operand 1 divided by Operand 2.\nResult Type must be a scalar or vector of integer type, whose Signedness operand is 0.\nThe types of Operand 1 and Operand 2 both must be the same as Result Type.\nResults are computed per component.  The resulting value is undefined if Operand 2 is 0.",
                    "MinWordCount": 5,
                    "Opcode": 134,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpSDiv",
                    "Description": "Signed-integer division of Operand 1 divided by Operand 2.\nResult Type must be a scalar or vector of integer type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.\nResults are computed per component.  Behavior is undefined if Operand 2 is 0, or if Operand 2 is -1 and Operand 1 is the minimum representable value for the operands' type, causing signed overflow.",
                    "MinWordCount": 5,
                    "Opcode": 135,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFDiv",
                    "Description": "Floating-point division of Operand 1 divided by Operand 2.\nResult Type must be a scalar or vector of floating-point type.\nThe types of Operand 1 and Operand 2 both must be the same as Result Type.\nResults are computed per component.  The resulting value is undefined if Operand 2 is 0.",
                    "MinWordCount": 5,
                    "Opcode": 136,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUMod",
                    "Description": "Unsigned modulo operation of Operand 1 modulo Operand 2.\nResult Type must be a scalar or vector of integer type, whose Signedness operand is 0.\nThe types of Operand 1 and Operand 2 both must be the same as Result Type.\nResults are computed per component.  The resulting value is undefined if Operand 2 is 0.",
                    "MinWordCount": 5,
                    "Opcode": 137,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpSRem",
                    "Description": "Signed remainder operation for the remainder whose sign matches the sign of Operand 1.\nResult Type must be a scalar or vector of integer type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.\nResults are computed per component.  Behavior is undefined if Operand 2 is 0, or if Operand 2 is -1 and Operand 1 is the minimum representable value for the operands' type, causing signed overflow. Otherwise, the result is the remainder r of Operand 1 divided by Operand 2 where if r \u2260 0, the sign of r is the same as the sign of Operand 1.",
                    "MinWordCount": 5,
                    "Opcode": 138,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpSMod",
                    "Description": "Signed remainder operation for the remainder whose sign matches the sign of Operand 2.\nResult Type must be a scalar or vector of integer type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.\nResults are computed per component.  Behavior is undefined if Operand 2 is 0, or if Operand 2 is -1 and Operand 1 is the minimum representable value for the operands' type, causing signed overflow. Otherwise, the result is the remainder r of Operand 1 divided by Operand 2 where if r \u2260 0, the sign of r is the same as the sign of Operand 2.",
                    "MinWordCount": 5,
                    "Opcode": 139,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFRem",
                    "Description": "The floating-point remainder whose sign matches the sign of Operand 1.\nResult Type must be a scalar or vector of floating-point type.\nThe types of Operand 1 and Operand 2 both must be the same as Result Type.\nResults are computed per component.  The resulting value is undefined if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand 1 divided by Operand 2 where if r \u2260 0, the sign of r is the same as the sign of Operand 1.",
                    "MinWordCount": 5,
                    "Opcode": 140,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFMod",
                    "Description": "The floating-point remainder whose sign matches the sign of Operand 2.\nResult Type must be a scalar or vector of floating-point type.\nThe types of Operand 1 and Operand 2 both must be the same as Result Type.\nResults are computed per component.  The resulting value is undefined if Operand 2 is 0.  Otherwise, the result is the remainder r of Operand 1 divided by Operand 2 where if r \u2260 0, the sign of r is the same as the sign of Operand 2.",
                    "MinWordCount": 5,
                    "Opcode": 141,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpVectorTimesScalar",
                    "Description": "Scale a floating-point vector.\nResult Type must be a vector of floating-point type.\nThe type of Vector must be the same as Result Type. Each component of Vector is multiplied by Scalar.\nScalar must have the same type as the Component Type in Result Type.",
                    "MinWordCount": 5,
                    "Opcode": 142,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Scalar"
                        }
                    ]
                },
                {
                    "Name": "OpMatrixTimesScalar",
                    "Description": "Scale a floating-point matrix.\nResult Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type.\nThe type of Matrix must be the same as Result Type. Each component in each column in Matrix is multiplied by Scalar.\nScalar must have the same type as the Component Type in Result Type.",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 143,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Matrix"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Scalar"
                        }
                    ]
                },
                {
                    "Name": "OpVectorTimesMatrix",
                    "Description": "Linear-algebraic Vector X Matrix.\nResult Type must be a vector of floating-point type.\nVector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of components in each column in Matrix.\nMatrix must be a matrix with the same Component Type as the Component Type in Result Type. Its number of columns must equal the number of components in Result Type.",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 144,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Matrix"
                        }
                    ]
                },
                {
                    "Name": "OpMatrixTimesVector",
                    "Description": "Linear-algebraic Matrix X Vector.\nResult Type must be a vector of floating-point type.\nMatrix must be an OpTypeMatrix whose Column Type is Result Type.\nVector must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Matrix.",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 145,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Matrix"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector"
                        }
                    ]
                },
                {
                    "Name": "OpMatrixTimesMatrix",
                    "Description": "Linear-algebraic multiply of LeftMatrix X RightMatrix.\nResult Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type.\nLeftMatrix must be a matrix whose Column Type is the same as the Column Type in Result Type.\nRightMatrix must be a matrix with the same Component Type as the Component Type in Result Type. Its number of columns must equal the number of columns in Result Type. Its columns must have the same number of components as the number of columns in LeftMatrix.",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 146,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "LeftMatrix"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RightMatrix"
                        }
                    ]
                },
                {
                    "Name": "OpOuterProduct",
                    "Description": "Linear-algebraic outer product of Vector 1 and Vector 2.\nResult Type must be an OpTypeMatrix whose Column Type is a vector of floating-point type.\nVector 1 must have the same type as the Column Type in Result Type.\nVector 2 must be a vector with the same Component Type as the Component Type in Result Type. Its number of components must equal the number of columns in Result Type.",
                    "EnablingCapabilities": [
                        "Matrix"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 147,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector 2"
                        }
                    ]
                },
                {
                    "Name": "OpDot",
                    "Description": "Dot product of Vector 1 and Vector 2.\nResult Type must be a floating-point type scalar.\nVector 1 and Vector 2 must be vectors of the same type, and their component type must be Result Type.",
                    "MinWordCount": 5,
                    "Opcode": 148,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector 2"
                        }
                    ]
                },
                {
                    "Name": "OpIAddCarry",
                    "Description": "Result is the unsigned integer addition of Operand 1 and Operand 2, including its carry.\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0.\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.\nResults are computed per component.\nMember 0 of the result gets the low-order bits (full component width) of the addition.\nMember 1 of the result gets the high-order (carry) bit of the result of the addition. That is, it gets the value 1 if the addition overflowed the component width, and 0 otherwise.",
                    "MinWordCount": 5,
                    "Opcode": 149,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpISubBorrow",
                    "Description": "Result is the unsigned integer subtraction of Operand 2 from Operand 1, and what it needed to borrow.\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0.\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.\nResults are computed per component.\nMember 0 of the result gets the low-order bits (full component width) of the subtraction. That is, if Operand 1 is larger than Operand 2, member 0 gets the full value of the subtraction;  if Operand 2 is larger than Operand 1, member 0 gets 2w + Operand 1 - Operand 2, where w is the component width.\nMember 1 of the result gets 0 if Operand 1 \u2265 Operand 2, and gets 1 otherwise.",
                    "MinWordCount": 5,
                    "Opcode": 150,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUMulExtended",
                    "Description": "Result is the full value of the unsigned integer multiplication of Operand 1 and Operand 2.\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type, whose Signedness operand is 0.\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as unsigned integers.\nResults are computed per component.\nMember 0 of the result gets the low-order bits of the multiplication.\nMember 1 of the result gets the high-order bits of the multiplication.",
                    "MinWordCount": 5,
                    "Opcode": 151,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpSMulExtended",
                    "Description": "Result is the full value of the signed integer multiplication of Operand 1 and Operand 2.\nResult Type must be from OpTypeStruct.  The struct must have two members, and the two members must be the same type.  The member type must be a scalar or vector of integer type.\nOperand 1 and Operand 2 must have the same type as the members of Result Type. These are consumed as signed integers.\nResults are computed per component.\nMember 0 of the result gets the low-order bits of the multiplication.\nMember 1 of the result gets the high-order bits of the multiplication.",
                    "MinWordCount": 5,
                    "Opcode": 152,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Bit Instructions",
            "Instructions": [
                {
                    "Name": "OpShiftRightLogical",
                    "Description": "Shift the bits in Base right by the number of bits specified in Shift.  The most-significant bits are zero filled.\nResult Type must be a scalar or vector of integer type.\nThe type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type.\nShift is consumed as an unsigned integer. The resulting value is undefined if Shift is greater than or equal to the bit width of the components of Base.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 194,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Shift"
                        }
                    ]
                },
                {
                    "Name": "OpShiftRightArithmetic",
                    "Description": "Shift the bits in Base right by the number of bits specified in Shift. The most-significant bits are filled with the sign bit from Base.\nResult Type must be a scalar or vector of integer type.\nThe type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type.\nShift is treated as unsigned. The resulting value is undefined if Shift is greater than or equal to the bit width of the components of Base.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 195,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Shift"
                        }
                    ]
                },
                {
                    "Name": "OpShiftLeftLogical",
                    "Description": "Shift the bits in Base left by the number of bits specified in Shift. The least-significant bits are zero filled.\nResult Type must be a scalar or vector of integer type.\nThe type of each Base and Shift must be a scalar or vector of integer type. Base and Shift must have the same number of components.  The number of components and bit width of the type of Base must be the same as in Result Type.\nShift is treated as unsigned. The resulting value is undefined if Shift is greater than or equal to the bit width of the components of Base.\nThe number of components and bit width of Result Type must match those Base type. All types must be integer types.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 196,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Shift"
                        }
                    ]
                },
                {
                    "Name": "OpBitwiseOr",
                    "Description": "Result is 1 if either Operand 1 or Operand 2 is 1. Result is 0 if both Operand 1 and Operand 2 are 0.\nResults are computed per component, and within each component, per bit.\nResult Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.",
                    "MinWordCount": 5,
                    "Opcode": 197,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpBitwiseXor",
                    "Description": "Result is 1 if exactly one of Operand 1 or Operand 2 is 1. Result is 0 if Operand 1 and Operand 2 have the same value.\nResults are computed per component, and within each component, per bit.\nResult Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.",
                    "MinWordCount": 5,
                    "Opcode": 198,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpBitwiseAnd",
                    "Description": "Result is 1 if both Operand 1 and Operand 2 are 1. Result is 0 if either Operand 1 or Operand 2 are 0.\nResults are computed per component, and within each component, per bit.\nResult Type must be a scalar or vector of integer type.  The type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same number of components as Result Type. They must have the same component width as Result Type.",
                    "MinWordCount": 5,
                    "Opcode": 199,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpNot",
                    "Description": "Complement the bits of Operand.\nResults are computed per component, and within each component, per bit.\nResult Type must be a scalar or vector of integer type.\nOperand\u2019s type  must be a scalar or vector of integer type.  It must have the same number of components as Result Type.  The component width must equal the component width in Result Type.",
                    "MinWordCount": 4,
                    "Opcode": 200,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand"
                        }
                    ]
                },
                {
                    "Name": "OpBitFieldInsert",
                    "Description": "Make a copy of an object, with a modified bit field that comes from another object.\nResults are computed per component.\nResult Type must be a scalar or vector of integer type.\nThe type of Base and Insert must be the same as Result Type.\nAny result bits numbered outside [Offset, Offset + Count -  1] (inclusive) come from the corresponding bits in Base.\nAny result bits numbered in [Offset, Offset + Count -  1] come, in order, from the bits numbered [0, Count - 1] of Insert.\nCount  must be an integer type scalar. Count is the number of bits taken from Insert. It is consumed as an unsigned value. Count can be 0, in which case the result is Base.\nOffset  must be an integer type scalar. Offset is the lowest-order bit of the bit field.  It is consumed as an unsigned value.\nThe resulting value is undefined if Count or Offset or their sum is greater than the number of bits in the result.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 7,
                    "Opcode": 201,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Insert"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Offset"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Count"
                        }
                    ]
                },
                {
                    "Name": "OpBitFieldSExtract",
                    "Description": "Extract a bit field from an object, with sign extension.\nResults are computed per component.\nResult Type must be a scalar or vector of integer type.\nThe type of Base must be the same as Result Type.\nIf Count is greater than 0: The bits of Base numbered in [Offset, Offset + Count -  1] (inclusive) become the bits numbered [0, Count - 1] of the result. The remaining bits of the result will all be the same as bit Offset + Count -  1 of Base.\nCount  must be an integer type scalar. Count is the number of bits extracted from Base. It is consumed as an unsigned value. Count can be 0, in which case the result is 0.\nOffset  must be an integer type scalar. Offset is the lowest-order bit of the bit field to extract from Base. It is consumed as an unsigned value.\nThe resulting value is undefined if Count or Offset or their sum is greater than the number of bits in the result.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 202,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Offset"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Count"
                        }
                    ]
                },
                {
                    "Name": "OpBitFieldUExtract",
                    "Description": "Extract a bit field from an object, without sign extension.\nThe semantics are the same as with OpBitFieldSExtract with the exception that there is no sign extension. The remaining bits of the result will all be 0.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 203,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Offset"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Count"
                        }
                    ]
                },
                {
                    "Name": "OpBitReverse",
                    "Description": "Reverse the bits in an object.\nResults are computed per component.\nResult Type must be a scalar or vector of integer type.\nThe type of Base must be the same as Result Type.\nThe bit-number n of the result is taken from bit-number Width - 1 - n of Base, where Width is the OpTypeInt operand of the Result Type.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 204,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        }
                    ]
                },
                {
                    "Name": "OpBitCount",
                    "Description": "Count the number of set bits in an object.\nResults are computed per component.\nResult Type must be a scalar or vector of integer type.  The components must be wide enough to hold the unsigned Width of Base as an unsigned value. That is, no sign bit is needed or counted when checking for a wide enough result width.\nBase must be a scalar or vector of integer type.  It must have the same number of components as Result Type.\nThe result is the unsigned value that is the number of bits in Base that are 1.",
                    "MinWordCount": 4,
                    "Opcode": 205,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Base"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Relational and Logical Instructions",
            "Instructions": [
                {
                    "Name": "OpAny",
                    "Description": "Result is true if any component of Vector is true, otherwise result is false.\nResult Type must be a Boolean type scalar.\nVector must be a vector of Boolean type.",
                    "MinWordCount": 4,
                    "Opcode": 154,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector"
                        }
                    ]
                },
                {
                    "Name": "OpAll",
                    "Description": "Result is true if all components of Vector are true, otherwise result is false.\nResult Type must be a Boolean type scalar.\nVector must be a vector of Boolean type.",
                    "MinWordCount": 4,
                    "Opcode": 155,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Vector"
                        }
                    ]
                },
                {
                    "Name": "OpIsNan",
                    "Description": "Result is true if x is an IEEE NaN, otherwise result is false.\nResult Type must be a scalar or vector of Boolean type.\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 156,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "x"
                        }
                    ]
                },
                {
                    "Name": "OpIsInf",
                    "Description": "Result is true if x is an IEEE Inf, otherwise result is false\nResult Type must be a scalar or vector of Boolean type.\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 157,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "x"
                        }
                    ]
                },
                {
                    "Name": "OpIsFinite",
                    "Description": "Result is true if x is an IEEE finite number, otherwise result is false.\nResult Type must be a scalar or vector of Boolean type.\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 158,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "x"
                        }
                    ]
                },
                {
                    "Name": "OpIsNormal",
                    "Description": "Result is true if x is an IEEE normal number, otherwise result is false.\nResult Type must be a scalar or vector of Boolean type.\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 159,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "x"
                        }
                    ]
                },
                {
                    "Name": "OpSignBitSet",
                    "Description": "Result is true if x has its sign bit set, otherwise result is false.\nResult Type must be a scalar or vector of Boolean type.\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\nResults are computed per component.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 160,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "x"
                        }
                    ]
                },
                {
                    "Name": "OpLessOrGreater",
                    "Description": "Deprecated (use OpFOrdNotEqual).\nHas the same semantics as OpFOrdNotEqual.\nResult Type must be a scalar or vector of Boolean type.\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\ny must have the same type as x.\nResults are computed per component.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 161,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "x"
                        },
                        {
                            "Type": "<id>",
                            "Description": "y"
                        }
                    ]
                },
                {
                    "Name": "OpOrdered",
                    "Description": "Result is true if both x == x and y == y are true, where IEEE comparison is used, otherwise result is false.\nResult Type must be a scalar or vector of Boolean type.\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\ny must have the same type as x.\nResults are computed per component.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 162,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "x"
                        },
                        {
                            "Type": "<id>",
                            "Description": "y"
                        }
                    ]
                },
                {
                    "Name": "OpUnordered",
                    "Description": "Result is true if either x or y is an IEEE NaN, otherwise result is false.\nResult Type must be a scalar or vector of Boolean type.\nx must be a scalar or vector of floating-point type.  It must have the same number of components as Result Type.\ny must have the same type as x.\nResults are computed per component.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 163,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "x"
                        },
                        {
                            "Type": "<id>",
                            "Description": "y"
                        }
                    ]
                },
                {
                    "Name": "OpLogicalEqual",
                    "Description": "Result is true if Operand 1 and Operand 2 have the same value. Result is false if Operand 1 and Operand 2 have different values.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 must be the same as Result Type.\nThe type of Operand 2 must be the same as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 164,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpLogicalNotEqual",
                    "Description": "Result is true if Operand 1 and Operand 2 have different values. Result is false if Operand 1 and Operand 2 have the same value.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 must be the same as Result Type.\nThe type of Operand 2 must be the same as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 165,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpLogicalOr",
                    "Description": "Result is true if either Operand 1 or Operand 2 is true. Result is false if both Operand 1 and Operand 2 are false.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 must be the same as Result Type.\nThe type of Operand 2 must be the same as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 166,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpLogicalAnd",
                    "Description": "Result is true if both Operand 1 and Operand 2 are true. Result is false if either Operand 1 or Operand 2 are false.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 must be the same as Result Type.\nThe type of Operand 2 must be the same as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 167,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpLogicalNot",
                    "Description": "Result is true if Operand is false.  Result is false if Operand is true.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand must be the same as Result Type.\nResults are computed per component.",
                    "MinWordCount": 4,
                    "Opcode": 168,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand"
                        }
                    ]
                },
                {
                    "Name": "OpSelect",
                    "Description": "Select between two objects. Before version 1.4, results are only computed per component.\nBefore version 1.4, Result Type must be a pointer, scalar, or vector. Starting with version 1.4, Result Type can additionally be a composite type other than a vector.\nThe types of Object 1 and Object 2 must be the same as Result Type.\nCondition must be a scalar or vector of Boolean type.\nIf Condition is a scalar and true, the result is Object 1. If Condition is a scalar and false, the result is Object 2.\nIf Condition is a vector, Result Type must be a vector with the same number of components as Condition and the result is a mix of Object 1 and Object 2: If a component of Condition is true, the corresponding component in the result is taken from Object 1, otherwise it is taken from Object 2.",
                    "MinWordCount": 6,
                    "Opcode": 169,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Condition"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Object 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Object 2"
                        }
                    ]
                },
                {
                    "Name": "OpIEqual",
                    "Description": "Integer comparison for equality.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 170,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpINotEqual",
                    "Description": "Integer comparison for inequality.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 171,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUGreaterThan",
                    "Description": "Unsigned-integer comparison if Operand 1 is greater than  Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 172,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpSGreaterThan",
                    "Description": "Signed-integer comparison if Operand 1 is greater than  Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 173,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUGreaterThanEqual",
                    "Description": "Unsigned-integer comparison if Operand 1 is greater than or equal to Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 174,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpSGreaterThanEqual",
                    "Description": "Signed-integer comparison if Operand 1 is greater than or equal to Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 175,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpULessThan",
                    "Description": "Unsigned-integer comparison if Operand 1 is less than Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 176,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpSLessThan",
                    "Description": "Signed-integer comparison if Operand 1 is less than Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 177,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpULessThanEqual",
                    "Description": "Unsigned-integer comparison if Operand 1 is less than or equal to Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 178,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpSLessThanEqual",
                    "Description": "Signed-integer comparison if Operand 1 is less than or equal to Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of integer type.  They must have the same component width, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 179,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFOrdEqual",
                    "Description": "Floating-point comparison for being ordered and equal.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 180,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFUnordEqual",
                    "Description": "Floating-point comparison for being unordered or equal.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 181,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFOrdNotEqual",
                    "Description": "Floating-point comparison for being ordered and not equal.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 182,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFUnordNotEqual",
                    "Description": "Floating-point comparison for being unordered or not equal.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 183,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFOrdLessThan",
                    "Description": "Floating-point comparison if operands are ordered and Operand 1 is less than Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 184,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFUnordLessThan",
                    "Description": "Floating-point comparison if operands are unordered or Operand 1 is less than Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 185,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFOrdGreaterThan",
                    "Description": "Floating-point comparison if operands are ordered and Operand 1 is greater than  Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 186,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFUnordGreaterThan",
                    "Description": "Floating-point comparison if operands are unordered or Operand 1 is greater than  Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 187,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFOrdLessThanEqual",
                    "Description": "Floating-point comparison if operands are ordered and Operand 1 is less than or equal to Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 188,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFUnordLessThanEqual",
                    "Description": "Floating-point comparison if operands are unordered or Operand 1 is less than or equal to Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 189,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFOrdGreaterThanEqual",
                    "Description": "Floating-point comparison if operands are ordered and Operand 1 is greater than or equal to Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 190,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpFUnordGreaterThanEqual",
                    "Description": "Floating-point comparison if operands are unordered or Operand 1 is greater than or equal to Operand 2.\nResult Type must be a scalar or vector of Boolean type.\nThe type of Operand 1 and Operand 2  must be a scalar or vector of floating-point type.  They must have the same type, and they must have the same number of components as Result Type.\nResults are computed per component.",
                    "MinWordCount": 5,
                    "Opcode": 191,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Derivative Instructions",
            "Instructions": [
                {
                    "Name": "OpDPdx",
                    "Description": "Same result as either OpDPdxFine or OpDPdxCoarse on P. Selection of which one is based on external factors.\nResult Type must be a scalar or vector of floating-point type.  The component width must be 32 bits.\nThe type of P must be the same as Result Type. P is the value to take the derivative of.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 207,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "P"
                        }
                    ]
                },
                {
                    "Name": "OpDPdy",
                    "Description": "Same result as either OpDPdyFine or OpDPdyCoarse on P. Selection of which one is based on external factors.\nResult Type must be a scalar or vector of floating-point type.  The component width must be 32 bits.\nThe type of P must be the same as Result Type. P is the value to take the derivative of.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 208,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "P"
                        }
                    ]
                },
                {
                    "Name": "OpFwidth",
                    "Description": "Result is the same as computing the sum of the absolute values of OpDPdx and OpDPdy on P.\nResult Type must be a scalar or vector of floating-point type.  The component width must be 32 bits.\nThe type of P must be the same as Result Type. P is the value to take the derivative of.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 209,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "P"
                        }
                    ]
                },
                {
                    "Name": "OpDPdxFine",
                    "Description": "Result is the partial derivative of P with respect to the window x coordinate.Uses local differencing based on the value of P for the current fragment and its immediate neighbor(s).\nResult Type must be a scalar or vector of floating-point type.  The component width must be 32 bits.\nThe type of P must be the same as Result Type. P is the value to take the derivative of.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "DerivativeControl"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 210,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "P"
                        }
                    ]
                },
                {
                    "Name": "OpDPdyFine",
                    "Description": "Result is the partial derivative of P with respect to the window y coordinate.Uses local differencing based on the value of P for the current fragment and its immediate neighbor(s).\nResult Type must be a scalar or vector of floating-point type.  The component width must be 32 bits.\nThe type of P must be the same as Result Type. P is the value to take the derivative of.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "DerivativeControl"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 211,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "P"
                        }
                    ]
                },
                {
                    "Name": "OpFwidthFine",
                    "Description": "Result is the same as computing the sum of the absolute values of OpDPdxFine and OpDPdyFine on P.\nResult Type must be a scalar or vector of floating-point type.  The component width must be 32 bits.\nThe type of P must be the same as Result Type. P is the value to take the derivative of.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "DerivativeControl"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 212,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "P"
                        }
                    ]
                },
                {
                    "Name": "OpDPdxCoarse",
                    "Description": "Result is the partial derivative of P with respect to the window x coordinate. Uses local differencing based on the value of P for the current fragment\u2019s neighbors, and possibly, but not necessarily, includes the value of P for the current fragment. That is, over a given area, the implementation can compute x derivatives in fewer unique locations than would be allowed for OpDPdxFine.\nResult Type must be a scalar or vector of floating-point type.  The component width must be 32 bits.\nThe type of P must be the same as Result Type. P is the value to take the derivative of.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "DerivativeControl"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 213,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "P"
                        }
                    ]
                },
                {
                    "Name": "OpDPdyCoarse",
                    "Description": "Result is the partial derivative of P with respect to the window y coordinate. Uses local differencing based on the value of P for the current fragment\u2019s neighbors, and possibly, but not necessarily, includes the value of P for the current fragment. That is, over a given area, the implementation can compute y derivatives in fewer unique locations than would be allowed for OpDPdyFine.\nResult Type must be a scalar or vector of floating-point type.  The component width must be 32 bits.\nThe type of P must be the same as Result Type. P is the value to take the derivative of.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "DerivativeControl"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 214,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "P"
                        }
                    ]
                },
                {
                    "Name": "OpFwidthCoarse",
                    "Description": "Result is the same as computing the sum of the absolute values of OpDPdxCoarse and OpDPdyCoarse on P.\nResult Type must be a scalar or vector of floating-point type.  The component width must be 32 bits.\nThe type of P must be the same as Result Type. P is the value to take the derivative of.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "DerivativeControl"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 215,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "P"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Control-Flow Instructions",
            "Instructions": [
                {
                    "Name": "OpPhi",
                    "Description": "The SSA phi function.\nThe result is selected based on control flow: If control reached the current block from Parent i, Result Id gets the value that Variable i had at the end of Parent i.\nResult Type can be any type.\nOperands are a sequence of pairs: (Variable 1, Parent 1 block), (Variable 2, Parent 2 block), \u2026 Each Parent i block is the label of an immediate predecessor in the CFG of the current block. There must be exactly one Parent i for each parent block of the current block in the CFG. If Parent i is reachable in the CFG and Variable i is defined in a block, that defining block must dominate Parent i. All Variables must have a type matching Result Type.\nWithin a block, this instruction must appear before all non-OpPhi instructions (except for OpLine and OpNoLine, which can be mixed with OpPhi).",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 245,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Variable",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpLoopMerge",
                    "Description": "Declare a structured loop.\nThis instruction must immediately precede either an OpBranch or OpBranchConditional instruction. That is, it must be the second-to-last instruction in its block.\nMerge Block is the label of the merge block for this structured loop.\nContinue Target is the label of a block targeted for processing a loop \"continue\".\nLoop Control Parameters appear in Loop Control-table order for any Loop Control setting that requires such a parameter.\nSee Structured Control Flow for more detail.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 246,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Merge Block"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Continue Target"
                        },
                        {
                            "Type": "Loop Control"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Loop Control Parameters",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpSelectionMerge",
                    "Description": "Declare a structured selection.\nThis instruction must immediately precede either an OpBranchConditional or OpSwitch instruction. That is, it must be the second-to-last instruction in its block.\nMerge Block is the label of the merge block for this structured selection.\nSee Structured Control Flow for more detail.",
                    "MinWordCount": 3,
                    "Opcode": 247,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Merge Block"
                        },
                        {
                            "Type": "Selection Control"
                        }
                    ]
                },
                {
                    "Name": "OpLabel",
                    "Description": "The label instruction of a block.\nReferences to a block are through the Result <id> of its label.",
                    "MinWordCount": 2,
                    "Opcode": 248,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpBranch",
                    "Description": "Unconditional branch to Target Label.\nTarget Label must be the Result <id> of an OpLabel instruction in the current function.\nThis instruction must be the last instruction in a block.",
                    "MinWordCount": 2,
                    "Opcode": 249,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Target Label"
                        }
                    ]
                },
                {
                    "Name": "OpBranchConditional",
                    "Description": "If Condition is true, branch to True Label, otherwise branch to False Label.\nCondition must be a Boolean type scalar.\nTrue Label must be an OpLabel in the current function.\nFalse Label must be an OpLabel in the current function.\nBranch weights are unsigned 32-bit integer literals. There must be either no Branch Weights or exactly two branch weights. If present, the first is the weight for branching to True Label, and the second is the weight for branching to False Label. The implied probability that a branch is taken is its weight divided by the sum of the two Branch weights. At least one weight must be non-zero. A weight of zero does not imply a branch is dead or permit its removal; branch weights are only hints. The sum of the two weights must not overflow a 32-bit unsigned integer.\nThis instruction must be the last instruction in a block.",
                    "MinWordCount": 4,
                    "VariableWordCount": true,
                    "Opcode": 250,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Condition"
                        },
                        {
                            "Type": "<id>",
                            "Description": "True Label"
                        },
                        {
                            "Type": "<id>",
                            "Description": "False Label"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Branch weights",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpSwitch",
                    "Description": "Multi-way branch to one of the operand label <id>.\nSelector must have a type of OpTypeInt. Selector is compared for equality to the Target literals.\nDefault must be the <id> of a label.  If Selector does not equal any of the Target literals, control flow branches to the Default label <id>.\nTarget must be alternating scalar integer literals and the <id> of a label.  If Selector equals a literal, control flow branches to the following label <id>. It is invalid for any two literal to be equal to each other. If Selector does not equal any literal, control flow branches to the Default label <id>. Each literal is interpreted with the type of Selector: The bit width of Selector\u2019s type is the width of each literal\u2019s type. If this width is not a multiple of 32-bits and the OpTypeInt Signedness is set to 1, the literal values are interpreted as being sign extended.\nThis instruction must be the last instruction in a block.",
                    "MinWordCount": 3,
                    "VariableWordCount": true,
                    "Opcode": 251,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Selector"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Default"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Target",
                            "Listed": true
                        },
                        {
                            "Type": "Label <id>",
                            "Description": "Target",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpKill",
                    "Description": "Fragment-shader discard.\nCeases all further processing in any invocation that executes it: Only instructions these invocations executed before OpKill have observable side effects. If this instruction is executed in non-uniform control flow, all subsequent control flow is non-uniform (for invocations that continue to execute).\nThis instruction must be the last instruction in a block.\nThis instruction is only valid in the Fragment Execution Model.",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "MinWordCount": 1,
                    "Opcode": 252
                },
                {
                    "Name": "OpReturn",
                    "Description": "Return with no value from a function with void return type.\nThis instruction must be the last instruction in a block.",
                    "MinWordCount": 1,
                    "Opcode": 253
                },
                {
                    "Name": "OpReturnValue",
                    "Description": "Return a value from a function.\nValue is the value returned, by copy, and must match the Return Type operand of the OpTypeFunction type of the OpFunction body this return instruction is in.\nThis instruction must be the last instruction in a block.",
                    "MinWordCount": 2,
                    "Opcode": 254,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpUnreachable",
                    "Description": "Behavior is undefined if this instruction is executed.\nThis instruction must be the last instruction in a block.",
                    "MinWordCount": 1,
                    "Opcode": 255
                },
                {
                    "Name": "OpLifetimeStart",
                    "Description": "Declare that an object was not defined before this instruction.\nPointer is a pointer to the object whose lifetime is starting. Its type must be an OpTypePointer with Storage Class Function.\nSize is an unsigned 32-bit integer.  Size must be 0 if Pointer is a pointer to a non-void type or the Addresses capability is not being used. If Size is non-zero, it is the number of bytes of memory whose lifetime is starting.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 3,
                    "Opcode": 256,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Size"
                        }
                    ]
                },
                {
                    "Name": "OpLifetimeStop",
                    "Description": "Declare that an object is dead after this instruction.\nPointer is a pointer to the object whose lifetime is ending. Its type must be an OpTypePointer with Storage Class Function.\nSize is an unsigned 32-bit integer.  Size must be 0 if Pointer is a pointer to a non-void type or the Addresses capability is not being used. If Size is non-zero, it is the number of bytes of memory whose lifetime is ending.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 3,
                    "Opcode": 257,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Size"
                        }
                    ]
                },
                {
                    "Name": "OpTerminateInvocation",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "Shader"
                    ],
                    "Reserved": true,
                    "MinWordCount": 1,
                    "Opcode": 4416
                }
            ]
        },
        {
            "Name": "Atomic Instructions",
            "Instructions": [
                {
                    "Name": "OpAtomicLoad",
                    "Description": "Atomically load through Pointer using the given Semantics. All subparts of the value that is loaded are read atomically with respect to all other atomic accesses to it within Scope.\nResult Type must be a scalar of integer type or floating-point type.\nPointer is the pointer to the memory to read. The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 6,
                    "Opcode": 227,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicStore",
                    "Description": "Atomically store through Pointer using the given Semantics. All subparts of Value are written atomically with respect to all other atomic accesses to it within Scope.\nPointer is the pointer to the memory to write. The type it points to  must be a scalar of integer type or floating-point type.\nValue is the value to write. The type of Value and the type pointed to by Pointer must be the same type.\nMemory is a memory Scope.",
                    "MinWordCount": 5,
                    "Opcode": 228,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicExchange",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value from copying Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be a scalar of integer type or floating-point type.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 229,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicCompareExchange",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value from Value only if Original Value equals Comparator, and\n3) store the New Value back through Pointer\u2019only if 'Original Value equaled Comparator.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nUse Equal for the memory semantics of this instruction when Value and Original Value compare equal.\nUse Unequal for the memory semantics of this instruction when Value and Original Value compare unequal. Unequal must not be set to Release or Acquire and Release. In addition, Unequal cannot be set to a stronger memory-order then Equal.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.  This type must also match the type of Comparator.\nMemory is a memory Scope.",
                    "MinWordCount": 9,
                    "Opcode": 230,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Equal"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Unequal"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Comparator"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicCompareExchangeWeak",
                    "Description": "Deprecated (use OpAtomicCompareExchange).\nHas the same semantics as OpAtomicCompareExchange.\nMemory is a memory Scope.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MissingAfter": "1.3",
                    "MinWordCount": 9,
                    "Opcode": 231,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Equal"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Unequal"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Comparator"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicIIncrement",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value through integer addition of 1 to Original Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 6,
                    "Opcode": 232,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicIDecrement",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value through integer subtraction of 1 from Original Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 6,
                    "Opcode": 233,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicIAdd",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value by integer addition of Original Value and Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 234,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicISub",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value by integer subtraction of Value from Original Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 235,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicSMin",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the smallest signed integer of Original Value and Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 236,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicUMin",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the smallest unsigned integer of Original Value and Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 237,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicSMax",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the largest signed integer of Original Value and Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 238,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicUMax",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value by finding the largest unsigned integer of Original Value and Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 239,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicAnd",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise AND of Original Value and Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 240,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicOr",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise OR of Original Value and Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 241,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicXor",
                    "Description": "Perform the following steps atomically with respect to any other atomic accesses within Scope to the same location:\n1) load through Pointer to get an Original Value,\n2) get a New Value by the bitwise exclusive OR of Original Value and Value, and\n3) store the New Value back through Pointer.\nThe instruction\u2019s result is the Original Value.\nResult Type must be an integer type scalar.\nThe type of Value must be the same as Result Type.  The type of the value pointed to by Pointer must be the same as Result Type.\nMemory is a memory Scope.",
                    "MinWordCount": 7,
                    "Opcode": 242,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicFlagTestAndSet",
                    "Description": "Atomically sets the flag value pointed to by Pointer to the set state.\nPointer must be a pointer to a 32-bit integer type representing an atomic flag.\nThe instruction\u2019s result is true if the flag was in the set state or false if the flag was in the clear state immediately before the operation.\nResult Type must be a Boolean type.\nThe resulting values are undefined if an atomic flag is modified by an instruction other than OpAtomicFlagTestAndSet or OpAtomicFlagClear.\nMemory is a memory Scope.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 318,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicFlagClear",
                    "Description": "Atomically sets the flag value pointed to by Pointer to the clear state.\nPointer must be a pointer to a 32-bit integer type representing an atomic flag.\nMemory Semantics must not be Acquire or AcquireRelease\nThe resulting values are undefined if an atomic flag is modified by an instruction other than OpAtomicFlagTestAndSet or OpAtomicFlagClear.\nMemory is a memory Scope.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 319,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        }
                    ]
                },
                {
                    "Name": "OpAtomicFAddEXT",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "AtomicFloat32AddEXT",
                        "AtomicFloat64AddEXT"
                    ],
                    "Reserved": true,
                    "MinWordCount": 7,
                    "Opcode": 6035,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Primitive Instructions",
            "Instructions": [
                {
                    "Name": "OpEmitVertex",
                    "Description": "Emits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.\nThis instruction must only be used when only one stream is present.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "MinWordCount": 1,
                    "Opcode": 218
                },
                {
                    "Name": "OpEndPrimitive",
                    "Description": "Finish the current primitive and start a new one.  No vertex is emitted.\nThis instruction must only be used when only one stream is present.",
                    "EnablingCapabilities": [
                        "Geometry"
                    ],
                    "MinWordCount": 1,
                    "Opcode": 219
                },
                {
                    "Name": "OpEmitStreamVertex",
                    "Description": "Emits the current values of all output variables to the current output primitive. After execution, the values of all output variables are undefined.\nStream must be an <id> of a constant instruction with a scalar integer type. That constant is the output-primitive stream number.\nThis instruction must only be used when multiple streams are present.",
                    "EnablingCapabilities": [
                        "GeometryStreams"
                    ],
                    "MinWordCount": 2,
                    "Opcode": 220,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Stream"
                        }
                    ]
                },
                {
                    "Name": "OpEndStreamPrimitive",
                    "Description": "Finish the current primitive and start a new one.  No vertex is emitted.\nStream must be an <id> of a constant instruction with a scalar integer type. That constant is the output-primitive stream number.\nThis instruction must only be used when multiple streams are present.",
                    "EnablingCapabilities": [
                        "GeometryStreams"
                    ],
                    "MinWordCount": 2,
                    "Opcode": 221,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Stream"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Barrier Instructions",
            "Instructions": [
                {
                    "Name": "OpControlBarrier",
                    "Description": "Wait for other invocations of this module to reach the current point of execution.\nAll invocations of this module within Execution scope reach this point of execution before any invocation proceeds beyond it.\nWhen Execution is Workgroup or larger, behavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction. When Execution is Subgroup or Invocation, the behavior of this instruction in non-uniform control flow is defined by the client API.\nIf Semantics is not None, this instruction also serves as an OpMemoryBarrier instruction, and also performs and adheres to the description and semantics of an OpMemoryBarrier instruction with the same Memory and Semantics operands. This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If Semantics is None, Memory is ignored.\nBefore version 1.3, it is only valid to use this instruction with TessellationControl, GLCompute, or Kernel execution models. There is no such restriction starting with version 1.3.\nIf used with the TessellationControl execution model, it also implicitly synchronizes the Output Storage Class:  Writes to Output variables performed by any invocation executed prior to a OpControlBarrier are visible to any other invocation proceeding beyond that OpControlBarrier.",
                    "MinWordCount": 4,
                    "Opcode": 224,
                    "Operands": [
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        }
                    ]
                },
                {
                    "Name": "OpMemoryBarrier",
                    "Description": "Control the order that memory accesses are observed.\nEnsures that memory accesses issued before this instruction are observed before memory accesses issued after this instruction. This control is ensured only for memory accesses issued by this invocation and observed by another invocation executing within Memory scope. If the Vulkan memory model is declared, this ordering only applies to memory accesses that use the NonPrivatePointer memory operand or NonPrivateTexel image operand.\nSemantics declares what kind of memory is being controlled and what kind of control to apply.\nTo execute both a memory barrier and a control barrier, see OpControlBarrier.",
                    "MinWordCount": 3,
                    "Opcode": 225,
                    "Operands": [
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        }
                    ]
                },
                {
                    "Name": "OpNamedBarrierInitialize",
                    "Description": "Declare a new named-barrier object.\nResult Type must be the type OpTypeNamedBarrier.\nSubgroup Count must be a 32-bit integer type scalar representing the number of subgroups that must reach the current point of execution.",
                    "EnablingCapabilities": [
                        "NamedBarrier"
                    ],
                    "MissingBefore": "1.1",
                    "MinWordCount": 4,
                    "Opcode": 328,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Subgroup Count"
                        }
                    ]
                },
                {
                    "Name": "OpMemoryNamedBarrier",
                    "Description": "Wait for other invocations of this module to reach the current point of execution.\nNamed Barrier must be the type OpTypeNamedBarrier.\nIf Semantics is not None, this instruction also serves as an OpMemoryBarrier instruction, and also performs and adheres to the description and semantics of an OpMemoryBarrier instruction with the same Memory and Semantics operands.  This allows atomically specifying both a control barrier and a memory barrier (that is, without needing two instructions). If Semantics None, Memory is ignored.",
                    "EnablingCapabilities": [
                        "NamedBarrier"
                    ],
                    "MissingBefore": "1.1",
                    "MinWordCount": 4,
                    "Opcode": 329,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Named Barrier"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Memory"
                        },
                        {
                            "Type": "Memory Semantics <id>",
                            "Description": "Semantics"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Group and Subgroup Instructions",
            "Instructions": [
                {
                    "Name": "OpGroupAsyncCopy",
                    "Description": "Perform an asynchronous group copy of Num Elements elements from Source to Destination. The asynchronous copy is performed by all work-items in a group.\nThis instruction results in an event object that can be used by OpGroupWaitEvents to wait for the async copy to finish.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type must be an OpTypeEvent object.\nDestination must be a pointer to a scalar or vector of floating-point type or integer type.\nDestination pointer Storage Class must be Workgroup or CrossWorkgroup.\nThe type of Source must be the same as Destination.\nIf Destination pointer Storage Class is Workgroup, the Source pointer Storage Class must be CrossWorkgroup. In this case Stride defines the stride in elements when reading from Source pointer.\nIf Destination pointer Storage Class is CrossWorkgroup, the Source pointer Storage Class must be Workgroup. In this case Stride defines the stride in elements when writing each element to Destination pointer.\nStride and NumElements must be a 32-bit integer type scalar if the addressing model is Physical32 and 64 bit integer type scalar if the Addressing Model is Physical64.\nEvent must have a type of OpTypeEvent.\nEvent can be used to associate the copy with a previous copy allowing an event to be shared by multiple copies. Otherwise Event should be an OpConstantNull.\nIf Event is not OpConstantNull, the result is the event object supplied by the Event operand.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 9,
                    "Opcode": 259,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Destination"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Source"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Num Elements"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Stride"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Event"
                        }
                    ]
                },
                {
                    "Name": "OpGroupWaitEvents",
                    "Description": "Wait for events generated by OpGroupAsyncCopy operations to complete. Events List points to Num Events event objects, which is released after the wait is performed.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nNum Events must be a 32-bit integer type scalar.\nEvents List must be a pointer to OpTypeEvent.",
                    "EnablingCapabilities": [
                        "Kernel"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 260,
                    "Operands": [
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Num Events"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Events List"
                        }
                    ]
                },
                {
                    "Name": "OpGroupAll",
                    "Description": "Evaluates a predicate for all invocations in the group,resulting in true if predicate evaluates to true for all invocations in the group, otherwise the result is false.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type must be a Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nPredicate must be a Boolean type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 261,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Predicate"
                        }
                    ]
                },
                {
                    "Name": "OpGroupAny",
                    "Description": "Evaluates a predicate for all invocations in the group,resulting in true if predicate evaluates to true for any invocation in the group, otherwise the result is false.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type must be a Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nPredicate must be a Boolean type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 262,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Predicate"
                        }
                    ]
                },
                {
                    "Name": "OpGroupBroadcast",
                    "Description": "Broadcast the Value of the invocation identified by the local id LocalId to the result of all invocations in the group.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type  must be a scalar or vector of floating-point type, integer type, or Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe type of Value must be the same as Result Type.\nLocalId must be an integer datatype. It must be a scalar, a vector with 2 components, or a vector with 3 components. Behavior is undefined unless LocalId is the same for all invocations in the group.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 263,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "LocalId"
                        }
                    ]
                },
                {
                    "Name": "OpGroupIAdd",
                    "Description": "An integer add group operation specified for all values of X specified by invocations in the group.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0.\nThe type of X must be the same as Result Type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 264,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupFAdd",
                    "Description": "A floating-point add group operation specified for all values of X specified by invocations in the group.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type  must be a scalar or vector of floating-point type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0.\nThe type of X must be the same as Result Type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 265,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupFMin",
                    "Description": "A floating-point minimum group operation specified for all values of X specified by invocations in the group.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type  must be a scalar or vector of floating-point type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is +INF.\nThe type of X must be the same as Result Type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 266,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupUMin",
                    "Description": "An unsigned integer minimum group operation specified for all values of X specified by invocations in the group.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is UINT_MAX when X is 32 bits wide and ULONG_MAX when X is 64 bits wide.\nThe type of X must be the same as Result Type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 267,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupSMin",
                    "Description": "A signed integer minimum group operation specified for all values of X specified by invocations in the group.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is INT_MAX when X is 32 bits wide and LONG_MAX when X is 64 bits wide.\nThe type of X must be the same as Result Type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 268,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupFMax",
                    "Description": "A floating-point maximum group operation specified for all values of X specified by invocations in the group.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type  must be a scalar or vector of floating-point type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is -INF.\nThe type of X must be the same as Result Type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 269,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupUMax",
                    "Description": "An unsigned integer maximum group operation specified for all values of X specified by invocations in the group.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0.\nThe type of X must be the same as Result Type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 270,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupSMax",
                    "Description": "A signed integer maximum group operation specified for all values of X specified by invocations in the group.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is INT_MIN when X is 32 bits wide and LONG_MIN when X is 64 bits wide.\nThe type of X must be the same as Result Type.",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 271,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupBallotKHR",
                    "SeeExtensions": [
                        "SPV_KHR_shader_ballot"
                    ],
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 4421,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Predicate"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupFirstInvocationKHR",
                    "SeeExtensions": [
                        "SPV_KHR_shader_ballot"
                    ],
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 4422,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupAllKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupVoteKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 4428,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Predicate"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupAnyKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupVoteKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 4429,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Predicate"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupAllEqualKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupVoteKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 4430,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Predicate"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupReadInvocationKHR",
                    "SeeExtensions": [
                        "SPV_KHR_shader_ballot"
                    ],
                    "EnablingCapabilities": [
                        "SubgroupBallotKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 4432,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Index"
                        }
                    ]
                },
                {
                    "Name": "OpGroupIAddNonUniformAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5000,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupFAddNonUniformAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5001,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupFMinNonUniformAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5002,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupUMinNonUniformAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5003,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupSMinNonUniformAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5004,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupFMaxNonUniformAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5005,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupUMaxNonUniformAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5006,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpGroupSMaxNonUniformAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "Groups"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5007,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "X"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupShuffleINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupShuffleINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5571,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Data"
                        },
                        {
                            "Type": "<id>",
                            "Description": "InvocationId"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupShuffleDownINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupShuffleINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5572,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Current"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Next"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Delta"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupShuffleUpINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupShuffleINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5573,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Previous"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Current"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Delta"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupShuffleXorINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupShuffleINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5574,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Data"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupBlockReadINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupBufferBlockIOINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 5575,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ptr"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupBlockWriteINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupBufferBlockIOINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 3,
                    "Opcode": 5576,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Ptr"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Data"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupImageBlockReadINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupImageBlockIOINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5577,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupImageBlockWriteINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupImageBlockIOINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 5578,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Data"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupImageMediaBlockReadINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupImageMediaBlockIOINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 7,
                    "Opcode": 5580,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Width"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Height"
                        }
                    ]
                },
                {
                    "Name": "OpSubgroupImageMediaBlockWriteINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "SubgroupImageMediaBlockIOINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5581,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Width"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Height"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Data"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Device-Side Enqueue Instructions",
            "Instructions": [
                {
                    "Name": "OpEnqueueMarker",
                    "Description": "Enqueue a marker command to the queue object specified by Queue. The marker command waits for a list of events to complete, or if the list is empty it waits for all previously enqueued commands in Queue to complete before the marker completes.\nResult Type must be a 32-bit integer type scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.\nQueue must be of the type OpTypeQueue.\nNum Events specifies the number of event objects in the wait list pointed to by Wait Events and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\nWait Events specifies the list of wait event objects and must be a pointer to OpTypeDeviceEvent.\nRet Event is a pointer to a device event which gets implicitly retained by this instruction.  It must have a type of OpTypePointer to OpTypeDeviceEvent. If Ret Event is set to null this instruction becomes a no-op.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 7,
                    "Opcode": 291,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Queue"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Num Events"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Wait Events"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ret Event"
                        }
                    ]
                },
                {
                    "Name": "OpEnqueueKernel",
                    "Description": "Enqueue the function specified by Invoke and the NDRange specified by ND Range for execution to the queue object specified by Queue.\nResult Type must be a 32-bit integer type scalar. A successful enqueue results in the value 0. A failed enqueue results in a non-0 value.\nQueue must be of the type OpTypeQueue.\nFlags must be an integer type scalar.  The content of Flags is interpreted as Kernel Enqueue Flags mask.\nThe type of ND Range must be an OpTypeStruct whose members are as described by the Result Type of OpBuildNDRange.\nNum Events specifies the number of event objects in the wait list pointed to by Wait Events and must be 32-bit integer type scalar, which is treated as an unsigned integer.\nWait Events specifies the list of wait event objects and must be a pointer to OpTypeDeviceEvent.\nRet Event must be a pointer to OpTypeDeviceEvent which gets implicitly retained by this instruction.\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\nEach Local Size operand corresponds (in order) to one OpTypePointer to Workgroup Storage Class parameter to the Invoke function, and specifies the number of bytes of Workgroup storage used to back the pointer during the execution of the Invoke function.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 13,
                    "VariableWordCount": true,
                    "Opcode": 292,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Queue"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Flags"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ND Range"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Num Events"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Wait Events"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ret Event"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Invoke"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Align"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Local Size",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpGetKernelNDrangeSubGroupCount",
                    "Description": "Result is the number of subgroups in each workgroup of the dispatch (except for the last in cases where the global size does not divide cleanly into work-groups) given the combination of the passed NDRange descriptor specified by ND Range and the function specified by Invoke.\nResult Type must be a 32-bit integer type scalar.\nThe type of ND Range must be an OpTypeStruct whose members are as described by the Result Type of OpBuildNDRange.\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 8,
                    "Opcode": 293,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ND Range"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Invoke"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Align"
                        }
                    ]
                },
                {
                    "Name": "OpGetKernelNDrangeMaxSubGroupSize",
                    "Description": "Result is the maximum sub-group size for the function specified by Invoke and the NDRange specified by ND Range.\nResult Type must be a 32-bit integer type scalar.\nThe type of ND Range must be an OpTypeStruct whose members are as described by the Result Type of OpBuildNDRange.\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 8,
                    "Opcode": 294,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ND Range"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Invoke"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Align"
                        }
                    ]
                },
                {
                    "Name": "OpGetKernelWorkGroupSize",
                    "Description": "Result is the maximum work-group size that can be used to execute the function specified by Invoke on the device.\nResult Type must be a 32-bit integer type scalar.\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 7,
                    "Opcode": 295,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Invoke"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Align"
                        }
                    ]
                },
                {
                    "Name": "OpGetKernelPreferredWorkGroupSizeMultiple",
                    "Description": "Result is the preferred multiple of work-group size for the function specified by Invoke. This is a performance hint. Specifying a work-group size that is not a multiple of this result as the value of the local work size does not fail to enqueue Invoke for execution unless the work-group size specified is larger than the device maximum.\nResult Type must be a 32-bit integer type scalar.\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 7,
                    "Opcode": 296,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Invoke"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Align"
                        }
                    ]
                },
                {
                    "Name": "OpRetainEvent",
                    "Description": "Increments the reference count of the event object specified by Event.\nBehavior is undefined if Event is not a valid event.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 2,
                    "Opcode": 297,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Event"
                        }
                    ]
                },
                {
                    "Name": "OpReleaseEvent",
                    "Description": "Decrements the reference count of the event object specified by Event. The event object is deleted once the event reference count is zero, the specific command identified by this event has completed (or terminated) and there are no commands in any device command queue that require a wait for this event to complete.\nBehavior is undefined if Event is not a valid event.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 2,
                    "Opcode": 298,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Event"
                        }
                    ]
                },
                {
                    "Name": "OpCreateUserEvent",
                    "Description": "Create a user event. The execution status of the created event is set to a value of 2 (CL_SUBMITTED).\nResult Type must be OpTypeDeviceEvent.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 3,
                    "Opcode": 299,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpIsValidEvent",
                    "Description": "Result is true if the event specified by Event is a valid event, otherwise false.\nResult Type must be a Boolean type.\nEvent must have a type of OpTypeDeviceEvent",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 300,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Event"
                        }
                    ]
                },
                {
                    "Name": "OpSetUserEventStatus",
                    "Description": "Sets the execution status of a user event specified by Event.Status can be either 0 (CL_COMPLETE) to indicate that this kernel and all its child kernels finished execution successfully, or a negative integer value indicating an error.\nEvent must have a type of OpTypeDeviceEvent that was produced by OpCreateUserEvent.\nStatus must have a type of 32-bit OpTypeInt treated as a signed integer.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 3,
                    "Opcode": 301,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Event"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Status"
                        }
                    ]
                },
                {
                    "Name": "OpCaptureEventProfilingInfo",
                    "Description": "Captures the profiling information specified by Profiling Info for the command associated with the event specified by Event in the memory pointed to by Value.The profiling information is available in the memory pointed to by Value after the command identified by Event has completed.\nEvent must have a type of OpTypeDeviceEvent that was produced by OpEnqueueKernel or OpEnqueueMarker.\nProfiling Info must be an integer type scalar.  The content of Profiling Info is interpreted as Kernel Profiling Info mask.\nValue must be a pointer to a scalar 8-bit integer type in the CrossWorkgroup Storage Class.\nIf Profiling Info is CmdExecTime, Value behavior is defined only if it points to 128-bit memory range.\nThe first 64 bits contain the elapsed time CL_PROFILING_COMMAND_END - CL_PROFILING_COMMAND_START for the command identified by Event in nanoseconds.\nThe second 64 bits contain the elapsed time CL_PROFILING_COMMAND_COMPLETE - CL_PROFILING_COMMAND_START for the command identified by Event in nanoseconds.\nNote: What is captured is undefined if this instruction is called multiple times for the same event.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 302,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Event"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Profiling Info"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpGetDefaultQueue",
                    "Description": "The result is the default device queue, or if a default device queue has not been created, a null queue object.\nResult Type must be an OpTypeQueue.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 3,
                    "Opcode": 303,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpBuildNDRange",
                    "Description": "Given the global work size specified by GlobalWorkSize, local work size specified by LocalWorkSize and global work offset specified by GlobalWorkOffset, builds the result as a 1D, 2D, or 3D ND-range descriptor structure.\nResult Type must be an OpTypeStruct with the following ordered list of members, starting from the first to last:\n1) 32-bit integer type scalar, that specifies the number of dimensions used to specify the global work-items and work-items in the work-group.\n2) OpTypeArray with 3 elements, where each element is 32-bit integer type scalar if the addressing model is Physical32 and 64-bit integer type scalar if the addressing model is Physical64. This member is an array of per-dimension unsigned values that describe the offset used to calculate the global ID of a work-item.\n3) OpTypeArray with 3 elements, where each element is 32-bit integer type scalar if the addressing model is Physical32 and 64-bit integer type scalar if the addressing model is Physical64. This member is an array of per-dimension unsigned values that describe the number of global work-items in the dimensions that execute the kernel function.\n4) OpTypeArray with 3 elements, where each element is 32-bit integer type scalar if the addressing model is Physical32 and 64-bit integer type scalar if the addressing model is Physical64. This member is an array of per-dimension unsigned values that describe the number of work-items that make up a work-group.\nGlobalWorkSize must be a scalar or an array with 2 or 3 components. Where the type of each element in the array is 32-bit integer type scalar if the addressing model is Physical32 or 64-bit integer type scalar if the addressing model is Physical64.\nThe type of LocalWorkSize must be the same as GlobalWorkSize.\nThe type of GlobalWorkOffset must be the same as GlobalWorkSize.",
                    "EnablingCapabilities": [
                        "DeviceEnqueue"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 304,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "GlobalWorkSize"
                        },
                        {
                            "Type": "<id>",
                            "Description": "LocalWorkSize"
                        },
                        {
                            "Type": "<id>",
                            "Description": "GlobalWorkOffset"
                        }
                    ]
                },
                {
                    "Name": "OpGetKernelLocalSizeForSubgroupCount",
                    "Description": "Result is the 1D local size to enqueue Invoke with Subgroup Count subgroups per workgroup.\nResult Type must be a 32-bit integer type scalar.\nSubgroup Count must be a 32-bit integer type scalar.\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
                    "EnablingCapabilities": [
                        "SubgroupDispatch"
                    ],
                    "MissingBefore": "1.1",
                    "MinWordCount": 8,
                    "Opcode": 325,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Subgroup Count"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Invoke"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Align"
                        }
                    ]
                },
                {
                    "Name": "OpGetKernelMaxNumSubgroups",
                    "Description": "Result is the maximum number of subgroups that can be used to execute Invoke on the devce.\nResult Type must be a 32-bit integer type scalar.\nInvoke must be an OpFunction whose OpTypeFunction operand has:\n- Result Type must be OpTypeVoid.\n- The first parameter must have a type of OpTypePointer to an 8-bit OpTypeInt.\n- An optional list of parameters, each of which must have a type of OpTypePointer to the Workgroup Storage Class.\nParam is the first parameter of the function specified by Invoke and must be a pointer to an 8-bit integer type scalar.\nParam Size is the size in bytes of the memory pointed to by Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.\nParam Align is the alignment of Param and must be a 32-bit integer type scalar, which is treated as an unsigned integer.",
                    "EnablingCapabilities": [
                        "SubgroupDispatch"
                    ],
                    "MissingBefore": "1.1",
                    "MinWordCount": 7,
                    "Opcode": 326,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Invoke"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Param Align"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Pipe Instructions",
            "Instructions": [
                {
                    "Name": "OpReadPipe",
                    "Description": "Read a packet from the pipe object specified by Pipe into Pointer. Result is 0 if the operation is successful and a negative value if the pipe is empty.\nResult Type must be a 32-bit integer type scalar.\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 7,
                    "Opcode": 274,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpWritePipe",
                    "Description": "Write a packet from Pointer to the pipe object specified by Pipe. Result is 0 if the operation is successful and a negative value if the pipe is full.\nResult Type must be a 32-bit integer type scalar.\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 7,
                    "Opcode": 275,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpReservedReadPipe",
                    "Description": "Read a packet from the reserved area specified by Reserve Id and Index of the pipe object specified by Pipe into Pointer. The reserved pipe entries are referred to by indices that go from 0 \u2026 Num Packets - 1. Result is 0 if the operation is successful and a negative value otherwise.\nResult Type must be a 32-bit integer type scalar.\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\nReserve Id must have a type of OpTypeReserveId.\nIndex must be a 32-bit integer type scalar, which is treated as an unsigned value.\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 9,
                    "Opcode": 276,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Reserve Id"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Index"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpReservedWritePipe",
                    "Description": "Write a packet from Pointer into the reserved area specified by Reserve Id and Index of the pipe object specified by Pipe. The reserved pipe entries are referred to by indices that go from 0 \u2026 Num Packets - 1. Result is 0 if the operation is successful and a negative value otherwise.\nResult Type must be a 32-bit integer type scalar.\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\nReserve Id must have a type of OpTypeReserveId.\nIndex must be a 32-bit integer type scalar, which is treated as an unsigned value.\nPointer must have a type of OpTypePointer with the same data type as Pipe and a Generic Storage Class.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 9,
                    "Opcode": 277,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Reserve Id"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Index"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpReserveReadPipePackets",
                    "Description": "Reserve Num Packets entries for reading from the pipe object specified by Pipe. Result is a valid reservation ID if the reservation is successful.\nResult Type must be an OpTypeReserveId.\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\nNum Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 7,
                    "Opcode": 278,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Num Packets"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpReserveWritePipePackets",
                    "Description": "Reserve num_packets entries for writing to the pipe object specified by Pipe. Result is a valid reservation ID if the reservation is successful.\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\nNum Packets must be a 32-bit OpTypeInt which is treated as an unsigned value.\nResult Type must be an OpTypeReserveId.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 7,
                    "Opcode": 279,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Num Packets"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpCommitReadPipe",
                    "Description": "Indicates that all reads to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe are completed.\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\nReserve Id must have a type of OpTypeReserveId.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 280,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Reserve Id"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpCommitWritePipe",
                    "Description": "Indicates that all writes to Num Packets associated with the reservation specified by Reserve Id and the pipe object specified by Pipe are completed.\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\nReserve Id must have a type of OpTypeReserveId.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 5,
                    "Opcode": 281,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Reserve Id"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpIsValidReserveId",
                    "Description": "Result is true if Reserve Id is a valid reservation id and false otherwise.\nResult Type must be a Boolean type.\nReserve Id must have a type of OpTypeReserveId.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 4,
                    "Opcode": 282,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Reserve Id"
                        }
                    ]
                },
                {
                    "Name": "OpGetNumPipePackets",
                    "Description": "Result is the number of available entries in the pipe object specified by Pipe. The number of available entries in a pipe is a dynamic value.  The result is considered immediately stale.\nResult Type must be a 32-bit integer type scalar, which should be treated as an unsigned value.\nPipe must have a type of OpTypePipe with ReadOnly or WriteOnly access qualifier.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 283,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpGetMaxPipePackets",
                    "Description": "Result is the maximum number of packets specified by the creation of Pipe.\nResult Type must be a 32-bit integer type scalar, which should be treated as an unsigned value.\nPipe must have a type of OpTypePipe with ReadOnly or WriteOnly access qualifier.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 284,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpGroupReserveReadPipePackets",
                    "Description": "Reserve Num Packets entries for reading from the pipe object specified by Pipe at group level. Result is a valid reservation id if the reservation is successful.\nThe reserved pipe entries are referred to by indices that go from 0 \u2026 Num Packets - 1.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type must be an OpTypeReserveId.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\nNum Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 8,
                    "Opcode": 285,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Num Packets"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpGroupReserveWritePipePackets",
                    "Description": "Reserve Num Packets entries for writing to the pipe object specified by Pipe at group level. Result is a valid reservation ID if the reservation is successful.\nThe reserved pipe entries are referred to by indices that go from 0 \u2026 Num Packets - 1.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nResult Type must be an OpTypeReserveId.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\nNum Packets must be a 32-bit integer type scalar, which is treated as an unsigned value.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 8,
                    "Opcode": 286,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Num Packets"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpGroupCommitReadPipe",
                    "Description": "A group level indication that all reads to Num Packets associated with the reservation specified by Reserve Id to the pipe object specified by Pipe are completed.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nPipe must have a type of OpTypePipe with ReadOnly access qualifier.\nReserve Id must have a type of OpTypeReserveId.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 287,
                    "Operands": [
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Reserve Id"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpGroupCommitWritePipe",
                    "Description": "A group level indication that all writes to Num Packets associated with the reservation specified by Reserve Id to the pipe object specified by Pipe are completed.\nBehavior is undefined if not all invocations of this module within Execution reach this point of execution.\nBehavior is undefined unless all invocations within Execution execute the same dynamic instance of this instruction.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nPipe must have a type of OpTypePipe with WriteOnly access qualifier.\nReserve Id must have a type of OpTypeReserveId.\nPacket Size must be a 32-bit integer type scalar that represents the size in bytes of each packet in the pipe.\nPacket Alignment must be a 32-bit integer type scalar that represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.",
                    "EnablingCapabilities": [
                        "Pipes"
                    ],
                    "MinWordCount": 6,
                    "Opcode": 288,
                    "Operands": [
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Reserve Id"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpConstantPipeStorage",
                    "Description": "Creates a pipe-storage object.\nResult Type must be OpTypePipeStorage.\nPacket Size is an unsigned 32-bit integer.  It represents the size in bytes of each packet in the pipe.\nPacket Alignment is an unsigned 32-bit integer.  It represents the alignment in bytes of each packet in the pipe.\nBehavior is undefined unless Packet Alignment > 0 and evenly divides Packet Size.\nCapacity is an unsigned 32-bit integer.  It is the minimum number of Packet Size blocks the resulting OpTypePipeStorage can hold.",
                    "EnablingCapabilities": [
                        "PipeStorage"
                    ],
                    "MissingBefore": "1.1",
                    "MinWordCount": 6,
                    "Opcode": 323,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Packet Alignment"
                        },
                        {
                            "Type": "Literal",
                            "Description": "Capacity"
                        }
                    ]
                },
                {
                    "Name": "OpCreatePipeFromPipeStorage",
                    "Description": "Creates a pipe object from a pipe-storage object.\nResult Type must be OpTypePipe.\nPipe Storage must be a pipe-storage object created from OpConstantPipeStorage.\nQualifier is the pipe access qualifier.",
                    "EnablingCapabilities": [
                        "PipeStorage"
                    ],
                    "MissingBefore": "1.1",
                    "MinWordCount": 4,
                    "Opcode": 324,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pipe Storage"
                        }
                    ]
                },
                {
                    "Name": "OpReadPipeBlockingINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "BlockingPipesINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5946,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                },
                {
                    "Name": "OpWritePipeBlockingINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "BlockingPipesINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5947,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Size"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packet Alignment"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Non-Uniform Instructions",
            "Instructions": [
                {
                    "Name": "OpGroupNonUniformElect",
                    "Description": "Result is true only in the active invocation with the lowest id in the group, otherwise result is false.\nResult Type must be a Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.",
                    "EnablingCapabilities": [
                        "GroupNonUniform"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 4,
                    "Opcode": 333,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformAll",
                    "Description": "Evaluates a predicate for all active invocations in the group, resulting in true if predicate evaluates to true for all active invocations in the group, otherwise the result is false.\nResult Type must be a Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nPredicate must be a Boolean type.",
                    "EnablingCapabilities": [
                        "GroupNonUniformVote"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 5,
                    "Opcode": 334,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Predicate"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformAny",
                    "Description": "Evaluates a predicate for all active invocations in the group, resulting in true if predicate evaluates to true for any active invocation in the group, otherwise the result is false.\nResult Type must be a Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nPredicate must be a Boolean type.",
                    "EnablingCapabilities": [
                        "GroupNonUniformVote"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 5,
                    "Opcode": 335,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Predicate"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformAllEqual",
                    "Description": "Evaluates a value for all active invocations in the group. The result is true if Value is equal for all active invocations in the group. Otherwise, the result is false.\nResult Type must be a Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nValue  must be a scalar or vector of floating-point type, integer type, or Boolean type. The compare operation is based on this type, and if it is a floating-point type, an ordered-and-equal compare is used.",
                    "EnablingCapabilities": [
                        "GroupNonUniformVote"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 5,
                    "Opcode": 336,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBroadcast",
                    "Description": "Result is the Value of the invocation identified by the id Id to all active invocations in the group.\nResult Type  must be a scalar or vector of floating-point type, integer type, or Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe type of Value must be the same as Result Type.\nId  must be a scalar of integer type, whose Signedness operand is 0.\nBefore version 1.5, Id must come from a constant instruction. Starting with version 1.5, this restriction is lifted. However, behavior is undefined when Id is not dynamically uniform.\nThe resulting value is undefined if Id is an inactive invocation, or is greater than or equal to the size of the group.",
                    "EnablingCapabilities": [
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "Opcode": 337,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Id"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBroadcastFirst",
                    "Description": "Result is the Value of the invocation from the active invocation with the lowest id in the group to all active invocations in the group.\nResult Type  must be a scalar or vector of floating-point type, integer type, or Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe type of Value must be the same as Result Type.",
                    "EnablingCapabilities": [
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 5,
                    "Opcode": 338,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBallot",
                    "Description": "Result is a bitfield value combining the Predicate value from all invocations in the group that execute the same dynamic instance of this instruction. The bit is set to one if the corresponding invocation is active and the Predicate for that invocation evaluated to true; otherwise, it is set to zero.\nResult Type  must be a vector of four components of integer type scalar, whose Signedness operand is 0.\nResult is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the group) is the higher bit number of the last bitmask needed to represent all bits of the group invocations.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nPredicate must be a Boolean type.",
                    "EnablingCapabilities": [
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 5,
                    "Opcode": 339,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Predicate"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformInverseBallot",
                    "Description": "Evaluates a value for all active invocations in the group, resulting in true if the bit in Value for the corresponding invocation is set to one, otherwise the result is false.\nResult Type must be a Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nValue  must be a vector of four components of integer type scalar, whose Signedness operand is 0.\nBehavior is undefined unless Value is the same for all invocations that execute the same dynamic instance of this instruction.\nValue is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the group) is the higher bit number of the last bitmask needed to represent all bits of the group invocations.",
                    "EnablingCapabilities": [
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 5,
                    "Opcode": 340,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBallotBitExtract",
                    "Description": "Evaluates a value for all active invocations in the group, resulting in true if the bit in Value that corresponds to Index is set to one, otherwise the result is false.\nResult Type must be a Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nValue  must be a vector of four components of integer type scalar, whose Signedness operand is 0.\nValue is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the group) is the higher bit number of the last bitmask needed to represent all bits of the group invocations.\nIndex  must be a scalar of integer type, whose Signedness operand is 0.\nThe resulting value is undefined if Index is greater than or equal to the size of the group.",
                    "EnablingCapabilities": [
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "Opcode": 341,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Index"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBallotBitCount",
                    "Description": "Result is the number of bits that are set to 1 in Value, considering only the bits in Value required to represent all bits of the group\u2019s invocations.\nResult Type  must be a scalar of integer type, whose Signedness operand is 0.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0.\nValue  must be a vector of four components of integer type scalar, whose Signedness operand is 0.\nValue is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the group) is the higher bit number of the last bitmask needed to represent all bits of the group invocations.",
                    "EnablingCapabilities": [
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "Opcode": 342,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBallotFindLSB",
                    "Description": "Find the least significant bit set to 1 in Value, considering only the bits in Value required to represent all bits of the group\u2019s invocations. If none of the considered bits is set to 1, the resulting value is undefined.\nResult Type  must be a scalar of integer type, whose Signedness operand is 0.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nValue  must be a vector of four components of integer type scalar, whose Signedness operand is 0.\nValue is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the group) is the higher bit number of the last bitmask needed to represent all bits of the group invocations.",
                    "EnablingCapabilities": [
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 5,
                    "Opcode": 343,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBallotFindMSB",
                    "Description": "Find the most significant bit set to 1 in Value, considering only the bits in Value required to represent all bits of the group\u2019s invocations.  If none of the considered bits is set to 1, the resulting value is undefined.\nResult Type  must be a scalar of integer type, whose Signedness operand is 0.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nValue  must be a vector of four components of integer type scalar, whose Signedness operand is 0.\nValue is a set of bitfields where the first invocation is represented in the lowest bit of the first vector component and the last (up to the size of the group) is the higher bit number of the last bitmask needed to represent all bits of the group invocations.",
                    "EnablingCapabilities": [
                        "GroupNonUniformBallot"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 5,
                    "Opcode": 344,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformShuffle",
                    "Description": "Result is the Value of the invocation identified by the id Id.\nResult Type  must be a scalar or vector of floating-point type, integer type, or Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe type of Value must be the same as Result Type.\nId  must be a scalar of integer type, whose Signedness operand is 0.\nThe resulting value is undefined if Id is an inactive invocation, or is greater than or equal to the size of the group.",
                    "EnablingCapabilities": [
                        "GroupNonUniformShuffle"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "Opcode": 345,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Id"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformShuffleXor",
                    "Description": "Result is the Value of the invocation identified by the current invocation\u2019s id within the group xor\u2019ed with Mask.\nResult Type  must be a scalar or vector of floating-point type, integer type, or Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe type of Value must be the same as Result Type.\nMask  must be a scalar of integer type, whose Signedness operand is 0.\nThe resulting value is undefined if current invocation\u2019s id within the group xor\u2019ed with Mask is an inactive invocation, or is greater than or equal to the size of the group.",
                    "EnablingCapabilities": [
                        "GroupNonUniformShuffle"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "Opcode": 346,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Mask"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformShuffleUp",
                    "Description": "Result is the Value of the invocation identified by the current invocation\u2019s id within the group - Delta.\nResult Type  must be a scalar or vector of floating-point type, integer type, or Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe type of Value must be the same as Result Type.\nDelta  must be a scalar of integer type, whose Signedness operand is 0.\nDelta is treated as unsigned and the resulting value is undefined if Delta is greater than the current invocation\u2019s id within the group or if the selected lane is inactive.",
                    "EnablingCapabilities": [
                        "GroupNonUniformShuffleRelative"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "Opcode": 347,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Delta"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformShuffleDown",
                    "Description": "Result is the Value of the invocation identified by the current invocation\u2019s id within the group + Delta.\nResult Type  must be a scalar or vector of floating-point type, integer type, or Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe type of Value must be the same as Result Type.\nDelta  must be a scalar of integer type, whose Signedness operand is 0.\nDelta is treated as unsigned and the resulting value is undefined if Delta is greater than or equal to the size of the group, or if the current invocation\u2019s id within the group + Delta is either an inactive invocation or greater than or equal to the size of the group.",
                    "EnablingCapabilities": [
                        "GroupNonUniformShuffleRelative"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "Opcode": 348,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Delta"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformIAdd",
                    "Description": "An integer add group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 349,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformFAdd",
                    "Description": "A floating point add group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of floating-point type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.  The method used to perform the group operation on the contributed Value(s) from active invocations is implementation defined.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 350,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformIMul",
                    "Description": "An integer multiply group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 1. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 351,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformFMul",
                    "Description": "A floating point multiply group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of floating-point type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 1. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.  The method used to perform the group operation on the contributed Value(s) from active invocations is implementation defined.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 352,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformSMin",
                    "Description": "A signed integer minimum group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is INT_MAX. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 353,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformUMin",
                    "Description": "An unsigned integer minimum group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of integer type, whose Signedness operand is 0.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is UINT_MAX. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 354,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformFMin",
                    "Description": "A floating point minimum group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of floating-point type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is +INF. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.  The method used to perform the group operation on the contributed Value(s) from active invocations is implementation defined. From the set of Value(s) provided by active invocations within a subgroup, if for any two Values one of them is a NaN, the other is chosen. If all Value(s) that are used by the current invocation are NaN, then the result is an undefined value.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 355,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformSMax",
                    "Description": "A signed integer maximum group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is INT_MIN. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 356,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformUMax",
                    "Description": "An unsigned integer maximum group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of integer type, whose Signedness operand is 0.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 357,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformFMax",
                    "Description": "A floating point maximum group operation of all Value operands contributed by active invocations in by group.\nResult Type  must be a scalar or vector of floating-point type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is -INF. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.  The method used to perform the group operation on the contributed Value(s) from active invocations is implementation defined. From the set of Value(s) provided by active invocations within a subgroup, if for any two Values one of them is a NaN, the other is chosen. If all Value(s) that are used by the current invocation are NaN, then the result is an undefined value.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 358,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBitwiseAnd",
                    "Description": "A bitwise and group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is ~0. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 359,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBitwiseOr",
                    "Description": "A bitwise or group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 360,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformBitwiseXor",
                    "Description": "A bitwise xor group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of integer type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 361,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformLogicalAnd",
                    "Description": "A logical and group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is ~0. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 362,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformLogicalOr",
                    "Description": "A logical or group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 363,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformLogicalXor",
                    "Description": "A logical xor group operation of all Value operands contributed by active invocations in the group.\nResult Type  must be a scalar or vector of Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe identity I for Operation is 0. If Operation is ClusteredReduce, ClusterSize must be present.\nThe type of Value must be the same as Result Type.\nClusterSize is the size of cluster to use. ClusterSize must be a scalar of integer type, whose Signedness operand is 0. ClusterSize must come from a constant instruction. Behavior is undefined unless ClusterSize is at least 1 and a power of 2. If ClusterSize is greater than the declared SubGroupSize, executing this instruction results in undefined behavior.",
                    "EnablingCapabilities": [
                        "GroupNonUniformArithmetic",
                        "GroupNonUniformClustered",
                        "GroupNonUniformPartitionedNV"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 364,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "Group Operation",
                            "Description": "Operation"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "ClusterSize",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformQuadBroadcast",
                    "Description": "Result is the Value of the invocation within the quad with a quad index equal to Index.\nResult Type  must be a scalar or vector of floating-point type, integer type, or Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe type of Value must be the same as Result Type.\nIndex  must be a scalar of integer type, whose Signedness operand is 0.\nBefore version 1.5, Index must come from a constant instruction. Starting with version 1.5, Index must be dynamically uniform.\nIf the value of Index is greater than or equal to 4, or refers to an inactive invocation, the resulting value is undefined.",
                    "EnablingCapabilities": [
                        "GroupNonUniformQuad"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "Opcode": 365,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Index"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformQuadSwap",
                    "Description": "Swap the Value of the invocation within the quad with another invocation in the quad using Direction.\nResult Type  must be a scalar or vector of floating-point type, integer type, or Boolean type.\nExecution is a Scope. It must be either Workgroup or Subgroup.\nThe type of Value must be the same as Result Type.\nDirection is the kind of swap to perform.\nDirection  must be a scalar of integer type, whose Signedness operand is 0.\nDirection must come from a constant instruction.\nThe value returned in Result is the value provided to Value by another invocation in the same quad scope instance. The invocation providing this value is determined according to Direction.\nA Direction of 0 indicates a horizontal swap;\n- Invocations with quad indices of 0 and 1 swap values\n- Invocations with quad indices of 2 and 3 swap values\nA Direction of 1 indicates a vertical swap;\n- Invocations with quad indices of 0 and 2 swap values\n- Invocations with quad indices of 1 and 3 swap values\nA Direction of 2 indicates a diagonal swap;\n- Invocations with quad indices of 0 and 3 swap values\n- Invocations with quad indices of 1 and 2 swap values\nIf an active invocation reads Value from an inactive invocation, the resulting value is undefined.",
                    "EnablingCapabilities": [
                        "GroupNonUniformQuad"
                    ],
                    "MissingBefore": "1.3",
                    "MinWordCount": 6,
                    "Opcode": 366,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Direction"
                        }
                    ]
                },
                {
                    "Name": "OpGroupNonUniformPartitionNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "GroupNonUniformPartitionedNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 5296,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Value"
                        }
                    ]
                }
            ]
        },
        {
            "Name": "Reserved Instructions",
            "Instructions": [
                {
                    "Name": "OpTraceRayKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 12,
                    "Opcode": 4445,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Accel"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Flags"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Cull Mask"
                        },
                        {
                            "Type": "<id>",
                            "Description": "SBT Offset"
                        },
                        {
                            "Type": "<id>",
                            "Description": "SBT Stride"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Miss Index"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Origin"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Tmin"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Direction"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Tmax"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Payload"
                        }
                    ]
                },
                {
                    "Name": "OpExecuteCallableKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 3,
                    "Opcode": 4446,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "SBT Index"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Callable Data"
                        }
                    ]
                },
                {
                    "Name": "OpConvertUToAccelerationStructureKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingKHR",
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 4447,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Accel"
                        }
                    ]
                },
                {
                    "Name": "OpIgnoreIntersectionKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 1,
                    "Opcode": 4448
                },
                {
                    "Name": "OpTerminateRayKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 1,
                    "Opcode": 4449
                },
                {
                    "Name": "OpTypeRayQueryKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 2,
                    "Opcode": 4472,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryInitializeKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 9,
                    "Opcode": 4473,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Accel"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayFlags"
                        },
                        {
                            "Type": "<id>",
                            "Description": "CullMask"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayOrigin"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayTMin"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayDirection"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayTMax"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryTerminateKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 2,
                    "Opcode": 4474,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGenerateIntersectionKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 3,
                    "Opcode": 4475,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "HitT"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryConfirmIntersectionKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 2,
                    "Opcode": 4476,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryProceedKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 4477,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionTypeKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 4479,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpFragmentMaskFetchAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "FragmentMaskAMD"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5011,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        }
                    ]
                },
                {
                    "Name": "OpFragmentFetchAMD",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "FragmentMaskAMD"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5012,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Image"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Coordinate"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Fragment Index"
                        }
                    ]
                },
                {
                    "Name": "OpReadClockKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "ShaderClockKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 5056,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        }
                    ]
                },
                {
                    "Name": "OpWritePackedPrimitiveIndices4x8NV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "MeshShadingNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 3,
                    "Opcode": 5299,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Index Offset"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Packed Indices"
                        }
                    ]
                },
                {
                    "Name": "OpReportIntersectionNV",
                    "Aliases": [
                        "OpReportIntersectionKHR"
                    ],
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5334,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Hit"
                        },
                        {
                            "Type": "<id>",
                            "Description": "HitKind"
                        }
                    ]
                },
                {
                    "Name": "OpIgnoreIntersectionNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 1,
                    "Opcode": 5335
                },
                {
                    "Name": "OpTerminateRayNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 1,
                    "Opcode": 5336
                },
                {
                    "Name": "OpTraceNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 12,
                    "Opcode": 5337,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Accel"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Flags"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Cull Mask"
                        },
                        {
                            "Type": "<id>",
                            "Description": "SBT Offset"
                        },
                        {
                            "Type": "<id>",
                            "Description": "SBT Stride"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Miss Index"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Origin"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Tmin"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Direction"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Ray Tmax"
                        },
                        {
                            "Type": "<id>",
                            "Description": "PayloadId"
                        }
                    ]
                },
                {
                    "Name": "OpTypeAccelerationStructureNV",
                    "Aliases": [
                        "OpTypeAccelerationStructureKHR"
                    ],
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingNV",
                        "RayTracingKHR",
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 2,
                    "Opcode": 5341,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpExecuteCallableNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayTracingNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 3,
                    "Opcode": 5344,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "SBT Index"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Callable DataId"
                        }
                    ]
                },
                {
                    "Name": "OpTypeCooperativeMatrixNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "CooperativeMatrixNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5358,
                    "Operands": [
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Component Type"
                        },
                        {
                            "Type": "Scope <id>",
                            "Description": "Execution"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Rows"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Columns"
                        }
                    ]
                },
                {
                    "Name": "OpCooperativeMatrixLoadNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "CooperativeMatrixNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "VariableWordCount": true,
                    "Opcode": 5359,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Stride"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Column Major"
                        },
                        {
                            "Type": "Memory Operands",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpCooperativeMatrixStoreNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "CooperativeMatrixNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "VariableWordCount": true,
                    "Opcode": 5360,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Pointer"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Object"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Stride"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Column Major"
                        },
                        {
                            "Type": "Memory Operands",
                            "Optional": true
                        }
                    ]
                },
                {
                    "Name": "OpCooperativeMatrixMulAddNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "CooperativeMatrixNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 6,
                    "Opcode": 5361,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "A"
                        },
                        {
                            "Type": "<id>",
                            "Description": "B"
                        },
                        {
                            "Type": "<id>",
                            "Description": "C"
                        }
                    ]
                },
                {
                    "Name": "OpCooperativeMatrixLengthNV",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "CooperativeMatrixNV"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 5362,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Type"
                        }
                    ]
                },
                {
                    "Name": "OpBeginInvocationInterlockEXT",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "FragmentShaderSampleInterlockEXT",
                        "FragmentShaderPixelInterlockEXT",
                        "FragmentShaderShadingRateInterlockEXT"
                    ],
                    "Reserved": true,
                    "MinWordCount": 1,
                    "Opcode": 5364
                },
                {
                    "Name": "OpEndInvocationInterlockEXT",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "FragmentShaderSampleInterlockEXT",
                        "FragmentShaderPixelInterlockEXT",
                        "FragmentShaderShadingRateInterlockEXT"
                    ],
                    "Reserved": true,
                    "MinWordCount": 1,
                    "Opcode": 5365
                },
                {
                    "Name": "OpDemoteToHelperInvocationEXT",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "DemoteToHelperInvocationEXT"
                    ],
                    "Reserved": true,
                    "MinWordCount": 1,
                    "Opcode": 5380
                },
                {
                    "Name": "OpIsHelperInvocationEXT",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "DemoteToHelperInvocationEXT"
                    ],
                    "Reserved": true,
                    "MinWordCount": 3,
                    "Opcode": 5381,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        }
                    ]
                },
                {
                    "Name": "OpUCountLeadingZerosINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 5585,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand"
                        }
                    ]
                },
                {
                    "Name": "OpUCountTrailingZerosINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 5586,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand"
                        }
                    ]
                },
                {
                    "Name": "OpAbsISubINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5587,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpAbsUSubINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5588,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpIAddSatINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5589,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUAddSatINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5590,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpIAverageINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5591,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUAverageINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5592,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpIAverageRoundedINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5593,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUAverageRoundedINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5594,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpISubSatINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5595,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUSubSatINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5596,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpIMul32x16INTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5597,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpUMul32x16INTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "IntegerFunctions2INTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5598,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 1"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Operand 2"
                        }
                    ]
                },
                {
                    "Name": "OpLoopControlINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "UnstructuredLoopControlsINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 1,
                    "VariableWordCount": true,
                    "Opcode": 5887,
                    "Operands": [
                        {
                            "Type": "Literal",
                            "Description": "Loop Control Parameters",
                            "Listed": true
                        }
                    ]
                },
                {
                    "Name": "OpFPGARegINTEL",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "FPGARegINTEL"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 5949,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Result"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Input"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetRayTMinKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 6016,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetRayFlagsKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 6017,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionTKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6018,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionInstanceCustomIndexKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6019,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionInstanceIdKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6020,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionInstanceShaderBindingTableRecordOffsetKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6021,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionGeometryIndexKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6022,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionPrimitiveIndexKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6023,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionBarycentricsKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6024,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionFrontFaceKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6025,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionCandidateAABBOpaqueKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 6026,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionObjectRayDirectionKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6027,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionObjectRayOriginKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6028,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetWorldRayDirectionKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 6029,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetWorldRayOriginKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 4,
                    "Opcode": 6030,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionObjectToWorldKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6031,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                },
                {
                    "Name": "OpRayQueryGetIntersectionWorldToObjectKHR",
                    "Description": "TBD",
                    "EnablingCapabilities": [
                        "RayQueryKHR"
                    ],
                    "Reserved": true,
                    "MinWordCount": 5,
                    "Opcode": 6032,
                    "Operands": [
                        {
                            "Type": "<id>",
                            "Description": "Result Type"
                        },
                        {
                            "Type": "Result <id>"
                        },
                        {
                            "Type": "<id>",
                            "Description": "RayQuery"
                        },
                        {
                            "Type": "<id>",
                            "Description": "Intersection"
                        }
                    ]
                }
            ]
        }
    ]
}
